Cognitive Complexity Reduction
Task Description
You are a strict code refactoring engine. You follow all rules exactly as written. Your task is to refactor code so that its cognitive complexity score is minimized while preserving behavior in an Apex project.

Please note:
1. The code must still function perfectly after the refactoring.
2. All imports, references, and method calls must be updated accordingly.
3. The style, formatting, and structure of the code must be preserved.
4. Do not introduce any new functionality, logic changes, or unrelated formatting changes.
5. For every modified file, return the complete updated file content to ensure that no changes are overlooked.
6. The semantics and behavior of the code must not change.
7. Only include files that required changes.
8. Respond with the code blocks only. Your entire response must be machine readable. Do not include any conversational filler.
9. If you are unsure, do not guess. Only modify code when the change is certain.
10. Every response must include meaningful modifications, improvements, or transformations. Returning the same code, even partially or with superficial edits, is strictly prohibited.
11. Your final output must pass the existing test suite. If your changes would cause any test to fail, revise your refactor until all tests pass.

Definitions
Cognitive complexity increases with:
- Deeply nested control structures
- Multiple branching paths
- Boolean logic with many operators
- Long methods with mixed responsibilities
- Repeated condition checks
- Hard to follow flow or side effects

Cognitive complexity decreases with:
- Early returns instead of deep nesting
- Extracting helper methods
- Flattening conditionals
- Replacing complex boolean expressions with named variables
- Clear, linear control flow
- Removing duplication

Examples of cognitive complexity reduction tasks:

Example 1:
Original Code:
File `ItemProcessor.cls`:
```apex
public class ItemProcessor {
    public static List<Integer> process(List<ItemWrapper> items) {
        List<Integer> result = new List<Integer>();
        for (ItemWrapper item : items) {
            if (item.isValid()) {
                if (!item.isExpired()) {
                    if (item.value > 10) {
                        result.add(item.value);
                    }
                }
            }
        }
        return result;
    }

    public class ItemWrapper {
        public Integer value;
        public Boolean isValid() { return true; }
        public Boolean isExpired() { return false; }
    }
}
```

Task:
1. Refactor the following code to reduce cognitive complexity while preserving behavior.
2. For EACH modified file, respond exactly in the following format:

File `Filename.cls`:
```apex
[Complete updated file content]
```

Output:
File `ItemProcessor.cls`:
```apex
public class ItemProcessor {
    public static List<Integer> process(List<ItemWrapper> items) {
        List<Integer> result = new List<Integer>();
        for (ItemWrapper item : items) {
            if (!item.isValid()) {
                continue;
            }
            if (item.isExpired()) {
                continue;
            }
            if (item.value <= 10) {
                continue;
            }
            result.add(item.value);
        }
        return result;
    }

    public class ItemWrapper {
        public Integer value;
        public Boolean isValid() { return true; }
        public Boolean isExpired() { return false; }
    }
}
```

Example 2:
Original Code:
File `Compute.cls`:
```apex
public class Compute {
    public static Integer compute(Integer x, Integer y, Integer z) {
        if (x > 0) {
            if (y > 0) {
                return x + y + z;
            } else {
                return x + z;
            }
        } else {
            return z;
        }
    }
}
```

Task:
1. Refactor the following code to reduce cognitive complexity while preserving behavior.
2. For EACH modified file, respond exactly in the following format:

File `Filename.cls`:
```apex
[Complete updated file content]
```

Output:
File `Compute.cls`:
```apex
public class Compute {
    public static Integer compute(Integer x, Integer y, Integer z) {
        if (x <= 0) {
            return z;
        }
        if (y <= 0) {
            return x + z;
        }
        return x + y + z;
    }
}
```

Your Task:
1. Refactor the following code to reduce cognitive complexity while preserving behavior.
2. For EACH modified file, respond exactly in the following format:

File `Filename.cls`:
```apex
[Complete updated file content]
```


Struktur:
force-app/
  dml/
    DML.cls
    DMLMock.cls
    DMLTest.cls
    IDML.cls
  factory/
    Factory.cls
    LazyFactory.cls
    LazyFactoryTest.cls
    RepoFactory.cls
    RepoFactoryMock.cls
    RepoFactoryMockTest.cls
  repository/
    AdditionalSoslObject.cls
    AggregateRecord.cls
    AggregateRepository.cls
    AggregateRepositoryTest.cls
    Aggregation.cls
    AggregationTest.cls
    Cursor.cls
    CursorTest.cls
    DateFunction.cls
    FieldLevelHistory.cls
    FieldLevelHistoryRepo.cls
    FieldLevelHistoryRepoTest.cls
    IAggregateRepository.cls
    IHistoryRepository.cls
    IRepository.cls
    Query.cls
    QueryField.cls
    QueryFieldTest.cls
    QueryTest.cls
    Repository.cls
    RepositorySortOrder.cls
    RepositoryTest.cls
    SearchGroup.cls
    SelectFunction.cls
    SObjectRepository.cls
    SObjectRepositoryTest.cls
  utils/
    AdditionalCoreTests.cls
    TestingUtils.cls

Code:


File `dml\DML.cls`:
```apex
public virtual without sharing class DML implements IDML {
  
  @TestVisible
  private static final Integer MAX_DML_CHUNKING = 10;

  private System.AccessLevel accessLevel = System.AccessLevel.SYSTEM_MODE;

  private Database.DMLOptions options {
    get {
      if (this.options == null) {
        this.options = new Database.DMLOptions();
      }
      this.options.OptAllOrNone = this.options.OptAllOrNone ?? true;
      return this.options;
    }
    set;
  }

  private enum OperationLoggingValue {
    INSERTING,
    UPDATING,
    UPSERTING,
    DELETING,
    UNDELETING,
    PUBLISHING
  }

  public virtual Database.SaveResult doInsert(SObject record) {
    return this.doInsert(new List<SObject>{ record })[0];
  }
  public virtual List<Database.SaveResult> doInsert(List<SObject> records) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.INSERTING, records);
    return Database.insert(records, this.options, this.accessLevel);
  }

  public virtual Database.SaveResult doUpdate(SObject record) {
    return this.doUpdate(new List<SObject>{ record })[0];
  }
  public virtual List<Database.SaveResult> doUpdate(List<SObject> records) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.UPDATING, records);
    return Database.update(records, this.options, this.accessLevel);
  }

  public virtual Database.UpsertResult doUpsert(SObject record) {
    return this.doUpsert(new List<SObject>{ record })[0];
  }

  public virtual List<Database.UpsertResult> doUpsert(List<SObject> records) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.UPSERTING, records);
    return Database.upsert(records, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual List<Database.UpsertResult> doUpsert(List<SObject> records, Schema.SObjectField externalIdField) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.UPSERTING, records);
    return Database.upsert(records, externalIdField, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual Database.UndeleteResult doUndelete(SObject record) {
    return this.doUndelete(new List<SObject>{ record })[0];
  }
  public virtual List<Database.UndeleteResult> doUndelete(List<SObject> records) {
    log(OperationLoggingValue.UNDELETING, records);
    return Database.undelete(records, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual Database.DeleteResult doDelete(SObject record) {
    return this.doDelete(new List<SObject>{ record })[0];
  }
  public virtual List<Database.DeleteResult> doDelete(List<SObject> records) {
    log(OperationLoggingValue.DELETING, records);
    return Database.delete(records, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual Database.DeleteResult doHardDelete(SObject record) {
    return this.doHardDelete(new List<SObject>{ record })[0];
  }
  public virtual List<Database.DeleteResult> doHardDelete(List<SObject> records) {
    List<Database.DeleteResult> results = this.doDelete(records);
    System.debug(System.LoggingLevel.FINE, 'emptying recycling bin...');
    Database.emptyRecycleBin(records);
    return results;
  }

  public virtual Database.SaveResult publish(SObject event) {
    log(OperationLoggingValue.PUBLISHING, event);
    return EventBus.publish(event);
  }
  public virtual List<Database.SaveResult> publish(List<SObject> events) {
    log(OperationLoggingValue.PUBLISHING, events);
    return EventBus.publish(events);
  }

  public DML setOptions(Database.DMLOptions options) {
    return this.setOptions(options, this.accessLevel);
  }

  public DML setOptions(Database.DMLOptions options, System.AccessLevel accessLevel) {
    this.options = options ?? this.options;
    this.accessLevel = accessLevel;
    return this;
  }

  private void sortToPreventChunkingErrors(List<SObject> records) {
    
    
    if (records.size() >= MAX_DML_CHUNKING) {
      records.sort();
    }
  }

  private static void log(OperationLoggingValue loggingValue, Object recordOrRecords) {
    Integer size = (recordOrRecords instanceof List<SObject>) ? ((List<SObject>) recordOrRecords).size() : 1;
    System.debug(
      System.LoggingLevel.FINE,
      loggingValue.name().toLowerCase() + ' ' + size + ' record' + (size > 1 ? 's' : '') + '...'
    );
  }
}
```


File `dml\DMLMock.cls`:
```apex
@SuppressWarnings('PMD.FieldNamingConventions,PMD.PropertyNamingConventions')
@IsTest
public class DMLMock extends DML {
  public static List<SObject> InsertedRecords = new List<SObject>();
  public static List<SObject> UpsertedRecords = new List<SObject>();
  public static List<SObject> UpdatedRecords = new List<SObject>();
  public static List<SObject> DeletedRecords = new List<SObject>();
  public static List<SObject> UndeletedRecords = new List<SObject>();
  public static List<SObject> PublishedRecords = new List<SObject>();

  public override List<Database.SaveResult> doInsert(List<SObject> records) {
    TestingUtils.generateIds(records);
    InsertedRecords.addAll(records);
    return (List<Database.SaveResult>) createDatabaseResults(Database.SaveResult.class, records);
  }

  public override List<Database.SaveResult> doUpdate(List<SObject> records) {
    UpdatedRecords.addAll(records);
    return (List<Database.SaveResult>) createDatabaseResults(Database.SaveResult.class, records);
  }

  public override List<Database.UpsertResult> doUpsert(List<SObject> records) {
    TestingUtils.generateIds(records);
    UpsertedRecords.addAll(records);
    return (List<Database.UpsertResult>) createDatabaseResults(Database.UpsertResult.class, records);
  }
  public override List<Database.UpsertResult> doUpsert(List<SObject> records, Schema.SObjectField field) {
    return this.doUpsert(records);
  }

  public override List<Database.UndeleteResult> doUndelete(List<SObject> records) {
    UndeletedRecords.addAll(records);
    return (List<Database.UndeleteResult>) createDatabaseResults(Database.UndeleteResult.class, records);
  }

  public override List<Database.DeleteResult> doDelete(List<SObject> records) {
    if (records?.isEmpty() == false) {
      DeletedRecords.addAll(records);
    }
    return (List<Database.DeleteResult>) createDatabaseResults(Database.DeleteResult.class, records);
  }

  public override List<Database.DeleteResult> doHardDelete(List<SObject> records) {
    return this.doDelete(records);
  }

  public override Database.SaveResult publish(SObject event) {
    PublishedRecords.add(event);
    return (Database.SaveResult) createDatabaseResult(Database.SaveResult.class, event);
  }
  public override List<Database.SaveResult> publish(List<SObject> events) {
    PublishedRecords.addAll(events);
    return (List<Database.SaveResult>) createDatabaseResults(Database.SaveResult.class, events);
  }

  public static RecordsWrapper Inserted {
    get {
      return new RecordsWrapper(InsertedRecords);
    }
  }

  public static RecordsWrapper Upserted {
    get {
      return new RecordsWrapper(UpsertedRecords);
    }
  }

  public static RecordsWrapper Updated {
    get {
      return new RecordsWrapper(UpdatedRecords);
    }
  }

  public static RecordsWrapper Deleted {
    get {
      return new RecordsWrapper(DeletedRecords);
    }
  }

  public static RecordsWrapper Undeleted {
    get {
      return new RecordsWrapper(UndeletedRecords);
    }
  }

  public static RecordsWrapper Published {
    get {
      return new RecordsWrapper(PublishedRecords);
    }
  }

  public class RecordsWrapper {
    List<SObject> recordList;
    private RecordsWrapper(List<SObject> recordList) {
      this.recordList = recordList;
    }

    public RecordsWrapper ofType(Schema.SObjectType sObjectType) {
      return new RecordsWrapper(this.getRecordsMatchingType(recordList, sObjectType));
    }

    public RecordsWrapper Accounts {
      get {
        return this.ofType(Schema.Account.SObjectType);
      }
    }

    public RecordsWrapper Leads {
      get {
        return this.ofType(Schema.Lead.SObjectType);
      }
    }

    public RecordsWrapper Contacts {
      get {
        return this.ofType(Schema.Contact.SObjectType);
      }
    }

    public RecordsWrapper Opportunities {
      get {
        return this.ofType(Schema.Opportunity.SObjectType);
      }
    }

    public RecordsWrapper Tasks {
      get {
        return this.ofType(Schema.Task.SObjectType);
      }
    }

    public List<SObject> Records {
      get {
        return recordList;
      }
    }

    public Boolean hasId(Id recordId) {
      return this.hasId(recordId, 'Id');
    }

    public Boolean hasId(Id relatedId, Schema.SObjectField idField) {
      return this.hasId(relatedId, idField.toString());
    }

    public Boolean hasId(Id relatedId, String idFieldName) {
      for (SObject record : this.recordList) {
        if (record.get(idFieldName) == relatedId) {
          return true;
        }
      }
      return false;
    }

    public Integer size() {
      return this.recordList.size();
    }

    public SObject singleOrDefault {
      get {
        if (recordList.size() > 1) {
          throw new IllegalArgumentException('More than one value in records list');
        }
        return recordList.size() == 0 ? null : recordList[0];
      }
    }

    public SObject firstOrDefault {
      get {
        if (recordList.size() > 0) {
          return recordList[0];
        }
        return null;
      }
    }

    private List<SObject> getRecordsMatchingType(List<SObject> records, Schema.SObjectType sObjectType) {
      List<SObject> matchingRecords = new List<SObject>();
      for (SObject record : records) {
        if (record.getSObjectType() == sObjectType) {
          matchingRecords.add(record);
        }
      }
      return matchingRecords;
    }
  }

  private static List<Object> createDatabaseResults(Type clazz, List<SObject> records) {
    List<Object> results = (List<Object>) Type.forName('List<' + clazz.getName() + '>').newInstance();
    for (SObject record : records) {
      results.add(createDatabaseResult(clazz, record));
    }
    return results;
  }

  private static Object createDatabaseResult(Type clazz, SObject record) {
    return JSON.deserialize('{"success": true, "id": "' + record.Id + '"}', clazz);
  }
}
```


File `dml\IDML.cls`:
```apex
public interface IDML {
  Database.SaveResult doInsert(SObject record);
  List<Database.SaveResult> doInsert(List<SObject> recordList);
  Database.SaveResult doUpdate(SObject record);
  List<Database.SaveResult> doUpdate(List<SObject> recordList);
  Database.UpsertResult doUpsert(SObject record);
  List<Database.UpsertResult> doUpsert(List<SObject> recordList);
  List<Database.UpsertResult> doUpsert(List<SObject> recordList, Schema.SObjectField externalIDField);
  Database.UndeleteResult doUndelete(SObject record);
  List<Database.UndeleteResult> doUndelete(List<SObject> recordList);

  Database.DeleteResult doDelete(SObject record);
  List<Database.DeleteResult> doDelete(List<SObject> recordList);
  Database.DeleteResult doHardDelete(SObject record);
  List<Database.DeleteResult> doHardDelete(List<SObject> recordList);

  Database.SaveResult publish(SObject platformEvent);
  List<Database.SaveResult> publish(List<SObject> platformEvent);

  IDML setOptions(Database.DMLOptions options);
  IDML setOptions(Database.DMLOptions options, System.AccessLevel accessLevel);
}
```


File `factory\Factory.cls`:
```apex
public virtual class Factory {
  public final RepoFactory repoFactory = new RepoFactory();

  @TestVisible
  private static Factory factory;

  @SuppressWarnings('PMD.EmptyStatementBlock')
  protected Factory() {
    
  }

  public static Factory getFactory() {
    
    
    if (factory == null) {
      factory = new Factory();
    }

    return factory;
  }

  
  

  @TestVisible
  private Factory withMocks {
    
    
    get {
      this.repoFactory.setFacade(new RepoFactoryMock.FacadeMock());
      return this;
    }
  }
}
```


File `factory\LazyFactory.cls`:
```apex
public without sharing virtual class LazyFactory {
  private static final Map<String, Instance> CACHED_INSTANCES = new Map<String, Instance>();

  public interface Instance {
  }

  public Instance load(String typeName) {
    return this.load(this.getTypeFromName(typeName, ''));
  }

  public Instance load(String typeName, String namespace) {
    return this.load(this.getTypeFromName(typeName, namespace));
  }

  public Instance load(Type type) {
    Instance possibleInstance = CACHED_INSTANCES.get(type.getName());
    if (possibleInstance == null) {
      possibleInstance = (Instance) type.newInstance();
      CACHED_INSTANCES.put(type.getName(), possibleInstance);
    }
    return possibleInstance;
  }

  private Type getTypeFromName(String typeName, String possibleNamespace) {
    return Type.forName(possibleNamespace, typeName);
  }
}
```


File `factory\RepoFactory.cls`:
```apex
public virtual class RepoFactory {
  private static final Map<Schema.SObjectType, IHistoryRepository> CACHED_REPOS = new Map<Schema.SObjectType, IHistoryRepository>();
  private Boolean shouldPrintBindVars = false;

  public Facade facade {
    get {
      if (this.facade == null) {
        this.facade = new Facade();
      }
      return this.facade;
    }
    protected set;
  }

  @SuppressWarnings('PMD.AvoidBooleanMethodParameters')
  public RepoFactory setShouldPrintBindVars(Boolean shouldPrintBindVars) {
    this.shouldPrintBindVars = shouldPrintBindVars;
    return this;
  }

  public IHistoryRepository getProfileRepo() {
    return this.facade.getRepo(Profile.SObjectType, new List<Schema.SObjectField>{ Profile.Name }, this);
  }

  public IDML getDML() {
    return this.facade.getDML();
  }

  public RepoFactory setFacade(Facade mockFacade) {
    if (Test.isRunningTest() == false) {
      throw new IllegalArgumentException('Should not call this outside of tests');
    }
    this.facade = mockFacade;
    return this;
  }

  public virtual class Facade {
    public virtual IDML getDML() {
      return new DML();
    }

    public virtual IHistoryRepository getRepo(
      Schema.SObjectType repoType,
      List<Schema.SObjectField> queryFields,
      RepoFactory repoFactory
    ) {
      IHistoryRepository potentiallyCachedInstance = CACHED_REPOS.get(repoType);
      if (potentiallyCachedInstance == null) {
        potentiallyCachedInstance = new FieldLevelHistoryRepo(repoType, queryFields, repoFactory);
        CACHED_REPOS.put(repoType, potentiallyCachedInstance);
        System.debug(System.LoggingLevel.FINER, 'Instantiating new repository of type: ' + repoType);
      } else {
        System.debug(System.LoggingLevel.FINER, 'Using cached repository of type: ' + repoType);
      }
      potentiallyCachedInstance.setShouldPrintBindVars(repoFactory.shouldPrintBindVars);
      return potentiallyCachedInstance;
    }
  }
}
```


File `factory\RepoFactoryMock.cls`:
```apex
@SuppressWarnings('PMD.FieldNamingConventions')
@IsTest
public class RepoFactoryMock extends RepoFactory {
  @TestVisible
  private static final Map<Schema.SObjectType, List<AggregateRecord>> AggregateResults = new Map<Schema.SObjectType, List<AggregateRecord>>();
  @TestVisible
  private static final List<Aggregation> AggregatesMade = new List<Aggregation>();
  @TestVisible
  private static final List<SObject> QueryResults = new List<SObject>();
  @TestVisible
  private static final List<Query> QueriesMade = new List<Query>();
  @TestVisible
  private static final Map<SObjectType, List<Cursor>> CursorResults = new Map<SObjectType, List<Cursor>>();
  @TestVisible
  private static final Map<Schema.SObjectType, List<FieldLevelHistory>> HistoryResults = new Map<Schema.SObjectType, List<FieldLevelHistory>>();
  @TestVisible
  private static final Map<SObjectType, List<AggregateRepository.GroupBy>> GroupByFields = new Map<SObjectType, List<AggregateRepository.GroupBy>>();
  @TestVisible
  private static final Map<SObjectType, Map<String, RepositorySortOrder>> FieldToSortOrders = new Map<SObjectType, Map<String, RepositorySortOrder>>();

  private static final Map<Schema.SObjectType, List<Schema.ChildRelationship>> CACHED_CHILD_RELATIONSHIPS = new Map<Schema.SObjectType, List<Schema.ChildRelationship>>();

  @TestVisible
  private static Boolean alwaysUseMock = false;

  private class ChildrenSObjects {
    public final List<SObject> records;
    public final Boolean done = true;
    public final Integer totalSize;

    public ChildrenSObjects(List<SObject> records) {
      this.records = records;
      this.totalSize = records.size();
    }
  }

  public static SObject addChildrenToRecord(SObject record, Schema.SObjectField childField, List<SObject> children) {
    List<Schema.ChildRelationship> childRelationships = CACHED_CHILD_RELATIONSHIPS.get(record.getSObjectType());
    if (childRelationships == null) {
      childRelationships = record.getSObjectType()
        .getDescribe(Schema.SObjectDescribeOptions.FULL)
        .getChildRelationships();
      CACHED_CHILD_RELATIONSHIPS.put(record.getSObjectType(), childRelationships);
    }
    String relationshipName;
    for (Schema.ChildRelationship childRelationship : childRelationships) {
      if (childRelationship.getField() == childField) {
        relationshipName = childRelationship.getRelationshipName();
        break;
      }
    }
    if (relationshipName != null) {
      String serializedMeta = JSON.serialize(record).removeEnd('}');
      String childrenJson = '"' + relationshipName + '" : ' + JSON.serialize(new ChildrenSObjects(children));
      serializedMeta += ',' + childrenJson + '}';
      return (SObject) JSON.deserialize(serializedMeta, SObject.class);
    }
    return record;
  }

  public class FacadeMock extends RepoFactory.Facade {
    public override IDML getDML() {
      return new DMLMock();
    }

    public override IHistoryRepository getRepo(
      Schema.SObjectType repoType,
      List<Schema.SObjectField> queryFields,
      RepoFactory repoFactory
    ) {
      return getRepoFromSObjectType(repoType, super.getRepo(repoType, queryFields, repoFactory), repoFactory);
    }
  }

  private static IHistoryRepository getRepoFromSObjectType(
    SObjectType sObjectType,
    IAggregateRepository fallback,
    RepoFactory repoFactory
  ) {
    IHistoryRepository repo;
    List<SObject> queriedResults = getResults(sObjectType);
    List<AggregateRecord> aggRecords = AggregateResults.get(sObjectType);
    List<FieldLevelHistory> historyRecords = HistoryResults.get(SObjectType);
    List<Cursor> cursorResults = CursorResults.get(sObjectType);

    if (
      queriedResults.size() > 0 ||
      aggRecords?.size() > 0 ||
      historyRecords?.size() > 0 ||
      cursorResults?.size() > 0 ||
      alwaysUseMock == true
    ) {
      RepoMock mock = new RepoMock(sObjectType, repoFactory);
      mock.results.addAll(queriedResults);
      if (aggRecords != null) {
        mock.aggRecords.addAll(aggRecords);
      }
      if (historyRecords != null) {
        mock.historyRecords.addAll(historyRecords);
      }
      repo = mock;
    } else {
      repo = (IHistoryRepository) fallback;
    }
    return repo;
  }

  private static List<SObject> getResults(Schema.SObjectType sobjType) {
    List<SObject> resultList = new List<SObject>();
    for (SObject potentialResult : QueryResults) {
      if (potentialResult.getSObjectType() == sobjType) {
        resultList.add(potentialResult);
      }
    }
    return resultList;
  }

  private class RepoMock extends FieldLevelHistoryRepo {
    private final List<SObject> results = new List<SObject>();
    private final List<AggregateRecord> aggRecords = new List<AggregateRecord>();
    private final List<FieldLevelHistory> historyRecords = new List<FieldLevelHistory>();

    private RepoMock(Schema.SObjectType sObjectType, RepoFactory repoFactory) {
      super(sObjectType, new List<Schema.SObjectField>(), repoFactory);
    }

    public override Cursor getCursor(List<Query> queries) {
      QueriesMade.addAll(queries);
      List<Cursor> cursorResults = CursorResults.get(this.repoType);
      return cursorResults.remove(0);
    }

    public override List<FieldLevelHistory> getHistory(List<Query> queries) {
      QueriesMade.addAll(queries);
      this.trackFieldToSortOrder();
      return this.historyRecords;
    }

    public override List<SObject> getAll() {
      return this.get(new List<Query>());
    }

    public override List<SObject> get(Query query) {
      return this.get(new List<Query>{ query });
    }

    public override List<SObject> get(List<Query> queries) {
      QueriesMade.addAll(queries);
      this.trackFieldToSortOrder();
      this.clearState();
      return this.results;
    }

    public override List<List<SObject>> getSosl(
      String searchTerm,
      List<Query> queries,
      List<AdditionalSoslObject> additionalSoslObjects
    ) {
      QueriesMade.addAll(queries);
      List<List<SObject>> results = new List<List<SObject>>{ this.results };
      for (AdditionalSoslObject additionalSoslObject : additionalSoslObjects) {
        if (additionalSoslObject.objectType != this.repoType) {
          results.add(getResults(additionalSoslObject.objectType));
          QueriesMade.addAll(additionalSoslObject.queryFilters);
        }
      }
      return results;
    }

    public override Integer count(List<Query> queries) {
      QueriesMade.addAll(queries);
      List<AggregateRecord> results = AggregateResults.get(this.repoType);
      this.clearState();
      if (results == null) {
        return super.count(queries);
      } else if (results.isEmpty() == false) {
        return results.remove(0).getCount();
      }
      return null;
    }

    public override List<AggregateRecord> aggregate(List<Aggregation> aggregations, List<Query> queries) {
      AggregatesMade.addAll(aggregations);
      QueriesMade.addAll(queries);

      List<AggregateRepository.GroupBy> fields = GroupByFields.get(this.repoType);
      if (fields == null) {
        fields = new List<AggregateRepository.GroupBy>();
        GroupByFields.put(this.repoType, fields);
      }
      fields.addAll(this.groupedByFieldNames);

      this.trackFieldToSortOrder();

      return this.aggRecords;
    }

    private void trackFieldToSortOrder() {
      Map<String, RepositorySortOrder> localFieldToSortOrders = FieldToSortOrders.get(this.repoType);
      if (localFieldToSortOrders == null) {
        localFieldToSortOrders = new Map<String, RepositorySortOrder>();
        FieldToSortOrders.put(this.repoType, localFieldToSortOrders);
      }
      localFieldToSortOrders.putAll(this.fieldToSortOrder);
    }
  }

  public class CursorMock extends Cursor {
    private final List<SObject> records;

    public CursorMock(List<SObject> records) {
      this.records = records;
    }

    public override List<SObject> fetch(Integer start, Integer advanceBy) {
      List<SObject> clonedRecords = records.deepClone();
      clonedRecords.clear();
      for (Integer index = start; index < this.getAdvanceBy(start, advanceBy) + start; index++) {
        clonedRecords.add(this.records[index]);
      }
      return clonedRecords;
    }

    public override Integer getNumRecords() {
      return this.records.size();
    }
  }
}
```


File `repository\AdditionalSoslObject.cls`:
```apex
public class AdditionalSoslObject {
  public final Schema.SObjectType objectType;
  public final Integer queryLimit;
  public final List<Query> queryFilters;
  public final List<Schema.SObjectField> selectFields;

  @SuppressWarnings('PMD.ExcessiveParameterList')
  public AdditionalSoslObject(
    Schema.SObjectType objectType,
    List<Schema.SObjectField> selectFields,
    List<Query> queryFilters,
    Integer queryLimit
  ) {
    this.objectType = objectType;
    this.queryFilters = queryFilters;
    this.queryLimit = queryLimit;
    this.selectFields = selectFields;
  }
}
```


File `repository\AggregateRecord.cls`:
```apex
public class AggregateRecord {
  private final Map<String, Object> keyToAggregateResult = new Map<String, Object>();
  private static final String COUNT_KEY = 'countKey';

  public AggregateRecord putAll(Map<String, Object> values) {
    this.keyToAggregateResult.putAll(values);
    return this;
  }

  public Object get(String key) {
    return this.keyToAggregateResult.get(key);
  }

  public Integer getCount() {
    return (Integer) this.keyToAggregateResult.get(COUNT_KEY);
  }

  public AggregateRecord setCount(Integer countAmount) {
    this.keyToAggregateResult.put(COUNT_KEY, countAmount);
    return this;
  }

  public Boolean equals(Object that) {
    if (that instanceof AggregateResult) {
      Map<String, Object> thatKeyToAggregateResult = ((AggregateResult) that).getPopulatedFieldsAsMap();
      return this.keyToAggregateResult.equals(thatKeyToAggregateResult);
    } else if (that instanceof AggregateRecord) {
      return this.keyToAggregateResult.equals(((AggregateRecord) that).keyToAggregateResult);
    }
    return false;
  }

  public Integer hashCode() {
    return this.keyToAggregateResult.hashCode();
  }
}
```


File `repository\AggregateRepository.cls`:
```apex
public without sharing virtual class AggregateRepository extends Repository implements IAggregateRepository {
  protected final Set<GroupBy> groupedByFieldNames = new Set<GroupBy>();
  private final Set<String> havingFields = new Set<String>();
  private List<Aggregation> aggregations;
  private Boolean isNumberCountQuery = false;

  @TestVisible
  private class GroupBy {
    private final String selectName;
    private final String groupByName;

    public GroupBy(String groupByName, String alias) {
      this.selectName = groupByName + ' ' + alias;
      this.groupByName = groupByName;
    }

    public GroupBy(String fieldName) {
      this.selectName = fieldName;
      this.groupByName = fieldName;
    }

    public String getSelectName() {
      return this.selectName;
    }

    public String getGroupByName() {
      return this.groupByName;
    }

    public Boolean equals(Object other) {
      if (other instanceof GroupBy) {
        GroupBy that = (GroupBy) other;
        return this.groupByName == that.groupByName && this.selectName == that.selectName;
      }
      return false;
    }

    public Integer hashCode() {
      return this.selectName.hashCode() + this.groupByName.hashCode();
    }
  }

  public AggregateRepository(
    Schema.SObjectType repoType,
    List<Schema.SObjectField> queryFields,
    RepoFactory repoFactory
  ) {
    super(repoType, queryFields, repoFactory);
  }

  public IAggregateRepository groupBy(DateFunction dateFunction, Schema.SObjectField fieldToken, String alias) {
    String groupByName = this.getFormattedDateFunction(dateFunction, fieldToken);
    this.groupedByFieldNames.add(new GroupBy(groupByName, alias));
    return this;
  }

  public IAggregateRepository groupBy(Schema.SObjectField fieldToken) {
    this.groupedByFieldNames.add(new GroupBy(fieldToken.getDescribe().getName()));
    return this;
  }

  public IAggregateRepository groupBy(List<Schema.SObjectField> parentFieldChain) {
    String parentFieldGroupBy = '';
    while (parentFieldChain.size() > 1) {
      parentFieldGroupBy += parentFieldChain.remove(0).getDescribe().getRelationshipName() + '.';
    }
    this.groupedByFieldNames.add(new GroupBy(parentFieldGroupBy + parentFieldChain.remove(0).getDescribe().getName()));
    return this;
  }

  public IAggregateRepository addSortOrder(Aggregation aggregate, RepositorySortOrder sortOrder) {
    this.fieldToSortOrder.put(aggregate.getBaseAggregation(), sortOrder);
    return this;
  }

  public IAggregateRepository addSortOrder(
    DateFunction dateFunction,
    Schema.SObjectField fieldToken,
    RepositorySortOrder sortOrder
  ) {
    this.fieldToSortOrder.put(this.getFormattedDateFunction(dateFunction, fieldToken), sortOrder);
    return this;
  }

  public IAggregateRepository addHaving(Aggregation aggregation, Query.Operator operator, Object value) {
    Query aggQuery = new AggregateQuery(operator, value);
    this.havingFields.add(aggregation.getBaseAggregation() + ' ' + aggQuery);
    this.bindVars.putAll(aggQuery.getBindVars());
    return this;
  }

  public Integer count() {
    return this.count(new List<Query>());
  }
  public Integer count(Query query) {
    return this.count(new List<Query>{ query });
  }
  public virtual Integer count(List<Query> queries) {
    this.isNumberCountQuery = true;
    String finalQuery = this.getFinalQuery(queries);
    this.logQuery('count query:\n' + finalQuery);
    Integer recordCount = Database.countQueryWithBinds(finalQuery, this.bindVars, this.accessLevel);
    System.debug(System.LoggingLevel.FINER, 'number of results: ' + recordCount);
    this.clearState();
    this.isNumberCountQuery = false;
    return recordCount;
  }

  public List<AggregateRecord> aggregate(Aggregation aggregation) {
    return this.aggregate(new List<Aggregation>{ aggregation }, new List<Query>());
  }
  public List<AggregateRecord> aggregate(Aggregation aggregation, Query query) {
    return this.aggregate(new List<Aggregation>{ aggregation }, new List<Query>{ query });
  }
  public List<AggregateRecord> aggregate(Aggregation aggregation, List<Query> queries) {
    return this.aggregate(new List<Aggregation>{ aggregation }, queries);
  }
  public List<AggregateRecord> aggregate(List<Aggregation> aggregations) {
    return this.aggregate(aggregations, new List<Query>());
  }
  public List<AggregateRecord> aggregate(List<Aggregation> aggregations, Query query) {
    return this.aggregate(aggregations, new List<Query>{ query });
  }
  public virtual List<AggregateRecord> aggregate(List<Aggregation> aggregations, List<Query> queries) {
    this.aggregations = aggregations;

    List<AggregateResult> results = (List<AggregateResult>) this.get(queries);
    List<AggregateRecord> aggregateRecords = new List<AggregateRecord>();
    for (AggregateResult result : results) {
      AggregateRecord aggRecord = new AggregateRecord();
      aggRecord.putAll(result.getPopulatedFieldsAsMap());
      aggregateRecords.add(aggRecord);
    }

    this.clearState();
    return aggregateRecords;
  }

  protected virtual override Set<String> addSelectFields() {
    Set<String> baseFields = new Set<String>();
    if (this.isNumberCountQuery) {
      baseFields.add('COUNT()');
      return baseFields;
    }

    if (this.aggregations != null) {
      for (Aggregation agg : aggregations) {
        baseFields.add(agg.toString());
      }
    }

    for (GroupBy groupBy : this.groupedByFieldNames) {
      baseFields.add(groupBy.getSelectName());
    }
    return baseFields.isEmpty() ? super.addSelectFields() : baseFields;
  }

  protected override String getFinalQuery(List<Query> queries) {
    String baseString = super.getFinalQuery(queries);
    if (this.groupedByFieldNames.isEmpty() == false) {
      String potentialOrderBy = null;
      String orderByKey = '\nORDER BY';
      if (baseString.contains(orderByKey)) {
        potentialOrderBy = baseString.substringAfter(orderByKey);
        baseString = baseString.replace(orderByKey + potentialOrderBy, '');
      }
      baseString += '\nGROUP BY ';
      for (GroupBy groupBy : this.groupedByFieldNames) {
        baseString += groupBy.getGroupByName() + ',';
      }
      baseString = baseString.removeEnd(',');
      
      if (this.havingFields.isEmpty() == false) {
        baseString += '\nHAVING ' + String.join(this.havingFields, ',');
      }
      if (potentialOrderBy != null) {
        baseString += orderByKey + potentialOrderBy;
      }
    }
    return baseString;
  }

  protected override void clearState() {
    super.clearState();
    this.havingFields.clear();
    this.groupedByFieldNames.clear();
    this.aggregations = null;
  }

  private String getFormattedDateFunction(DateFunction dateFunction, Schema.SObjectField fieldToken) {
    return dateFunction.name() + '(' + fieldToken + ')';
  }

  private class AggregateQuery extends Query {
    public AggregateQuery(Query.Operator op, Object value) {
      super('', op, value);
    }
  }
}
```


File `repository\Aggregation.cls`:
```apex
public class Aggregation {
  private enum Operation {
    COUNT,
    COUNT_DISTINCT,
    SUM,
    AVERAGE,
    MAX,
    MIN
  }

  private final Operation op;
  private final String fieldName;
  private final String alias;

  private Aggregation(Operation op, Schema.SObjectField fieldToken, String alias) {
    this.op = op;
    this.fieldName = fieldToken.getDescribe().getName();
    this.alias = alias;
  }

  public static Aggregation sum(Schema.SObjectField fieldToken, String alias) {
    return new Aggregation(Operation.SUM, fieldToken, alias);
  }

  public static Aggregation count(Schema.SObjectField fieldToken, String alias) {
    return new Aggregation(Operation.COUNT, fieldToken, alias);
  }

  public static Aggregation countDistinct(Schema.SObjectfield fieldToken, String alias) {
    return new Aggregation(Operation.COUNT_DISTINCT, fieldToken, alias);
  }

  public static Aggregation average(Schema.SObjectfield fieldToken, String alias) {
    return new Aggregation(Operation.AVERAGE, fieldToken, alias);
  }

  public static Aggregation max(Schema.SObjectfield fieldToken, String alias) {
    return new Aggregation(Operation.MAX, fieldToken, alias);
  }

  public static Aggregation min(Schema.SObjectfield fieldToken, String alias) {
    return new Aggregation(Operation.MIN, fieldToken, alias);
  }

  public String getAlias() {
    return this.alias;
  }

  public String getFieldName() {
    return this.fieldName;
  }

  public String getBaseAggregation() {
    return this.op.name() + '(' + fieldName + ')';
  }

  public override String toString() {
    return this.getBaseAggregation() + ' ' + this.alias;
  }

  public Boolean equals(Object that) {
    return this.toString() == that.toString();
  }

  public Integer hashCode() {
    return this.toString().hashCode();
  }
}
```


File `repository\Cursor.cls`:
```apex
public virtual without sharing class Cursor {
  public static final Integer MAX_FETCH_SIZE {
    get {
      MAX_FETCH_SIZE = MAX_FETCH_SIZE ?? maxRecordsPerFetchCall;
      return MAX_FETCH_SIZE;
    }
    private set;
  }

  private static final Integer MAX_FETCHES_PER_TRANSACTION = Limits.getLimitFetchCallsOnApexCursor();

  @TestVisible
  private static Integer maxRecordsPerFetchCall = 2000;

  @TestVisible
  private static Integer localFetchesMade;

  private Integer cursorNumRecords;
  private Integer fetchesPerTransaction = MAX_FETCHES_PER_TRANSACTION;
  private final Database.Cursor cursor;

  public Cursor(String finalQuery, Map<String, Object> bindVars, System.AccessLevel accessLevel) {
    try {
      this.cursor = Database.getCursorWithBinds(finalQuery, bindVars, accessLevel);
    } catch (FatalCursorException e) {
      System.debug(
        System.LoggingLevel.WARN,
        'Error creating cursor. This can happen if there are no records returned by the query: ' + e.getMessage()
      );
    }
  }

  public Cursor setFetchesPerTransaction(Integer possibleFetchesPerTransaction) {
    
    if (possibleFetchesPerTransaction == 0) {
      return this;
    }
    if (possibleFetchesPerTransaction > MAX_FETCHES_PER_TRANSACTION) {
      System.debug(
        System.LoggingLevel.DEBUG,
        'Fetches per transaction: ' +
          possibleFetchesPerTransaction +
          ' exceeded platform max fetches per transaction: ' +
          MAX_FETCHES_PER_TRANSACTION +
          ', defaulting to platform max'
      );
      possibleFetchesPerTransaction = MAX_FETCHES_PER_TRANSACTION;
    }
    this.fetchesPerTransaction = possibleFetchesPerTransaction;
    return this;
  }

  @SuppressWarnings('PMD.EmptyStatementBlock')
  protected Cursor() {
  }

  public virtual List<SObject> fetch(Integer start, Integer advanceBy) {
    if (this.getNumRecords() == 0) {
      System.debug(System.LoggingLevel.DEBUG, 'Bypassing fetch call, no records to fetch');
      return new List<SObject>();
    }
    localFetchesMade = localFetchesMade ?? 0;
    Integer localStart = start;
    List<SObject> results = new List<SObject>();
    while (
      localFetchesMade < this.fetchesPerTransaction &&
      results.size() < this.getNumRecords() &&
      localStart < start + advanceBy
    ) {
      Integer actualAdvanceBy = this.getAdvanceBy(localStart, advanceBy);
      results.addAll(this.cursor?.fetch(localStart, actualAdvanceBy) ?? new List<SObject>());
      localStart += actualAdvanceBy;
      localFetchesMade++;
    }
    return results;
  }

  public virtual Integer getNumRecords() {
    this.cursorNumRecords = this.cursorNumRecords ?? this.cursor?.getNumRecords() ?? 0;
    return this.cursorNumRecords;
  }

  protected Integer getAdvanceBy(Integer start, Integer advanceBy) {
    Integer possibleFetchSize = Math.min(advanceBy, this.getNumRecords() - start);
    if (possibleFetchSize > maxRecordsPerFetchCall) {
      System.debug(
        System.LoggingLevel.DEBUG,
        'Fetch size: ' +
          possibleFetchSize +
          ' exceeded platform max fetch size of ' +
          maxRecordsPerFetchCall +
          ', defaulting to max fetch size'
      );
      possibleFetchSize = maxRecordsPerFetchCall;
    } else if (possibleFetchSize < 0) {
      possibleFetchSize = 0;
    }
    return possibleFetchSize;
  }
}
```


File `repository\DateFunction.cls`:
```apex

public enum DateFunction {
  CALENDAR_MONTH,
  CALENDAR_QUARTER,
  CALENDAR_YEAR,
  DAY_IN_MONTH,
  DAY_IN_WEEK,
  DAY_IN_YEAR,
  DAY_ONLY,
  FISCAL_MONTH,
  FISCAL_QUARTER,
  FISCAL_YEAR,
  HOUR_IN_DAY,
  WEEK_IN_MONTH,
  WEEK_IN_YEAR
}
```


File `repository\FieldLevelHistory.cls`:
```apex
@SuppressWarnings('PMD.PropertyNamingConventions')
public class FieldLevelHistory {
  private String parentLookupName = 'ParentId';

  public Datetime CreatedDate { get; set; }
  public Id CreatedById { get; set; }
  public Object NewValue { get; set; }
  public Object OldValue { get; set; }
  public String Field { get; set; }
  public Id ParentId { get; private set; }

  public override String toString() {
    return JSON.serialize(this);
  }

  public FieldLevelHistory setValues(Map<String, Object> values) {
    this.CreatedById = (Id) values.get('CreatedById');
    Object possibleCreatedDate = values.get('CreatedDate');
    this.CreatedDate = Datetime.valueOfGmt(String.valueOf(possibleCreatedDate).replace('T', ' ').remove('"'));
    this.Field = (String) values.get('Field');
    this.NewValue = values.get('NewValue');
    this.OldValue = values.get('OldValue');
    this.setParentId(values);
    return this;
  }

  public FieldLevelHistory setParentLookup(Schema.SObjectField fieldToken) {
    if (fieldToken != null) {
      this.parentLookupName = fieldToken.getDescribe().getName();
    }
    return this;
  }

  private void setParentId(Map<String, Object> values) {
    this.ParentId = (Id) values.get(this.parentLookupName);
  }
}
```


File `repository\FieldLevelHistoryRepo.cls`:
```apex
public virtual without sharing class FieldLevelHistoryRepo extends AggregateRepository implements IHistoryRepository {
  private Schema.SObjectField parentFieldToken;
  private final Set<String> fullHistoryFields;

  private Boolean isHistoryQuery = false;

  public FieldLevelHistoryRepo(
    Schema.SObjectType repoType,
    List<Schema.SObjectField> queryFields,
    RepoFactory repoFactory
  ) {
    super(repoType, queryFields, repoFactory);
    this.fullHistoryFields = this.repoType.getDescribe(SObjectDescribeOptions.DEFERRED).fields.getMap().keySet();
  }

  public virtual List<FieldLevelHistory> getAllHistory() {
    return this.getHistory(new List<Query>());
  }

  public List<FieldLevelHistory> getHistory(Query query) {
    return this.getHistory(new List<Query>{ query });
  }

  public virtual List<FieldLevelHistory> getHistory(List<Query> queries) {
    this.isHistoryQuery = true;
    List<Object> unwrappedHistoryRecords = this.get(queries);
    this.isHistoryQuery = false;
    if (unwrappedHistoryRecords instanceof List<FieldLevelHistory>) {
      return (List<FieldLevelHistory>) unwrappedHistoryRecords;
    }

    List<FieldLevelHistory> historyRecords = new List<FieldLevelHistory>();
    for (Object obj : unwrappedHistoryRecords) {
      FieldLevelHistory historyRecord = new FieldLevelHistory()
        .setParentLookup(this.parentFieldToken)
        .setValues((Map<String, Object>) JSON.deserializeUntyped(JSON.serialize(obj)));
      historyRecords.add(historyRecord);
    }
    return historyRecords;
  }

  public FieldLevelHistoryRepo setParentField(Schema.SObjectField parentField) {
    this.parentFieldToken = parentField;
    return this;
  }

  protected virtual override Set<String> addSelectFields() {
    return this.isHistoryQuery ? this.fullHistoryFields : super.addSelectFields();
  }
}
```


File `repository\IAggregateRepository.cls`:
```apex
public interface IAggregateRepository extends IRepository {
  IAggregateRepository groupBy(Schema.SObjectField fieldToken);
  IAggregateRepository groupBy(DateFunction dateFunction, Schema.SObjectField fieldToken, String alias);
  IAggregateRepository groupBy(List<Schema.SObjectField> parentFieldChain);

  IAggregateRepository addHaving(Aggregation aggregation, Query.Operator operator, Object value);

  IAggregateRepository addSortOrder(Aggregation aggregate, RepositorySortOrder sortOrder);
  IAggregateRepository addSortOrder(
    DateFunction dateFunction,
    Schema.SObjectField fieldToken,
    RepositorySortOrder sortOrder
  );

  
  Integer count();
  Integer count(Query query);
  Integer count(List<Query> queries);
  
  List<AggregateRecord> aggregate(Aggregation aggregation);
  List<AggregateRecord> aggregate(Aggregation aggregation, Query query);
  List<AggregateRecord> aggregate(Aggregation aggregation, List<Query> queries);
  List<AggregateRecord> aggregate(List<Aggregation> aggregations);
  List<AggregateRecord> aggregate(List<Aggregation> aggregations, Query query);
  List<AggregateRecord> aggregate(List<Aggregation> aggregations, List<Query> queries);
}
```


File `repository\IHistoryRepository.cls`:
```apex
public interface IHistoryRepository extends IAggregateRepository {
  
  
  List<FieldLevelHistory> getHistory(Query query);
  List<FieldLevelHistory> getHistory(List<Query> queries);
  List<FieldLevelHistory> getAllHistory();

  
  
  IHistoryRepository setParentField(Schema.SObjectField parentField);
}
```


File `repository\IRepository.cls`:
```apex
@SuppressWarnings('PMD.AvoidBooleanMethodParameters,PMD.ExcessiveParameterList')
public interface IRepository extends IDML {
  Cursor getCursor(List<Query> queries);

  Database.QueryLocator getQueryLocator(List<Query> queries);
  Database.QueryLocator getQueryLocator(List<Query> queries, Boolean shouldAddChildFields);

  List<SObject> get(Query query);
  List<SObject> get(List<Query> queries);
  List<SObject> getAll();

  List<List<SObject>> getSosl(String searchTerm, Query query);
  List<List<SObject>> getSosl(String searchTerm, List<Query> queries);
  List<List<SObject>> getSosl(String searchTerm, List<Query> queries, List<AdditionalSoslObject> additionalSoslObjects);
  IRepository setSearchGroup(SearchGroup searchGroup);

  IRepository setShouldPrintBindVars(Boolean shouldPrintBindVars);
  IRepository clearBindVars();
  IRepository setAccessLevel(System.AccessLevel accessLevel);
  IRepository setLimit(Integer limitAmount);

  IRepository addSortOrder(Schema.SObjectField fieldToken, RepositorySortOrder sortOrder);
  IRepository addSortOrder(List<Schema.SObjectField> fieldChain, RepositorySortOrder sortOrder);

  IRepository addBaseFields(List<Schema.SObjectField> fields);

  IRepository addFunctionBaseField(SelectFunction selectFunction, Schema.SObjectField field);
  IRepository addFunctionBaseFields(SelectFunction selectFunction, List<Schema.SObjectField> fields);
  IRepository addFunctionBaseFields(SelectFunction selectFunction, Map<Schema.SObjectField, String> fieldsToAliases);

  IRepository addParentFields(Schema.SObjectField relationshipField, List<Schema.SObjectField> parentFields);
  IRepository addParentFields(List<Schema.SObjectField> relationshipFields, List<Schema.SObjectField> parentFields);

  IRepository addChildFields(Schema.SObjectField childFieldToken, List<SObjectField> childFields);
  IRepository addChildFields(Schema.SObjectField childFieldToken, IRepository childRepo);
  IRepository addChildFields(
    Schema.SObjectField childFieldToken,
    List<Schema.SObjectField> childFields,
    List<Query> optionalWhereFilters,
    Map<String, RepositorySortOrder> fieldToSortOrder,
    Integer limitBy
  );
  IRepository addChildFields(
    Schema.SObjectField childFieldToken,
    IRepository childRepo,
    List<Query> optionalWhereFilters,
    Map<String, RepositorySortOrder> fieldToSortOrder,
    Integer limitBy
  );
  IRepository addChildFields(
    Schema.SObjectField childFieldToken,
    List<QueryField> childFields,
    List<Query> optionalWhereFilters,
    Map<String, RepositorySortOrder> fieldToSortOrder,
    Integer limitBy
  );
}
```


File `repository\Query.cls`:
```apex
@SuppressWarnings(
  'PMD.EmptyStatementBlock,PMD.ExcessivePublicCount,PMD.ExcessiveParameterList,PMD.FieldNamingConventions'
)
public virtual class Query {
  private Boolean hasBeenCompared = false;
  private Boolean isSoslEmpty = false;
  private String predicateKey;

  public enum Operator {
    EQUALS,
    NOT_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUAL,
    GREATER_THAN,
    GREATER_THAN_OR_EQUAL,
    ALIKE, 
    NOT_LIKE
  }

  public final Operator operator;
  private final String field;
  private final Schema.SObjectField fieldToken;
  private final Object predicate;
  private final Map<String, Object> bindVars = new Map<String, Object>();

  private static final String BIND_VAR_MERGE = 'bindVar{0}';
  private static final String EMPTYISH_STRING = '()';

  private static Integer BIND_VAR_NUMBER = 0;
  @TestVisible
  private static Boolean shouldPerformStrictEquals = false;

  public Boolean isSoslEmpty() {
    return this.isSoslEmpty;
  }

  public Query usingParent(Schema.SObjectField parentField) {
    return this.usingParent(new List<Schema.SObjectField>{ parentField });
  }

  public Query usingParent(List<SObjectField> parentFields) {
    parentFields.add(this.fieldToken);
    return new ParentQuery(parentFields, this.operator, this.predicate);
  }

  public static Query subquery(Schema.SObjectField field, Schema.SObjectField innerMatchingField, Query subcondition) {
    return subquery(field, innerMatchingField.getDescribe().getSObjectType(), innerMatchingField, subcondition);
  }

  public static Query subquery(
    Schema.SObjectField field,
    Schema.SObjectType objectType,
    Schema.SObjectField innerMatchingField,
    Query subcondition
  ) {
    return new SubQuery(field, objectType, innerMatchingField, subcondition);
  }

  public static Query equals(SObjectField field, Object predicate) {
    return new Query(field, Operator.EQUALS, predicate);
  }

  public static Query notEquals(SObjectField field, Object predicate) {
    return new Query(field, Operator.NOT_EQUALS, predicate);
  }

  public static Query lessThan(SObjectField field, Object predicate) {
    return new Query(field, Operator.LESS_THAN, predicate);
  }

  public static Query lessThanOrEqual(SObjectField field, Object predicate) {
    return new Query(field, Operator.LESS_THAN_OR_EQUAL, predicate);
  }

  public static Query greaterThan(SObjectField field, Object predicate) {
    return new Query(field, Operator.GREATER_THAN, predicate);
  }

  public static Query greaterThanOrEqual(SObjectField field, Object predicate) {
    return new Query(field, Operator.GREATER_THAN_OR_EQUAL, predicate);
  }

  
  public static Query likeQuery(SObjectField field, Object predicate) {
    return new Query(field, Operator.ALIKE, predicate);
  }

  public static Query notLike(SObjectField field, Object predicate) {
    return new Query(field, Operator.NOT_LIKE, predicate);
  }

  
  public static Query orQuery(Query innerQuery, Query secondInnerQuery) {
    return orQuery(new List<Query>{ innerQuery, secondInnerQuery });
  }

  public static Query orQuery(List<Query> innerQueries) {
    return new OrQuery(innerQueries);
  }

  
  public static Query andQuery(Query innerQuery, Query secondInnerQuery) {
    return andQuery(new List<Query>{ innerQuery, secondInnerQuery });
  }

  public static Query andQuery(List<Query> innerQueries) {
    return new AndQuery(innerQueries);
  }

  public static String getBuiltUpParentFieldName(List<Schema.SObjectField> parentFields) {
    String builtUpFieldName = '';
    for (Integer index = 0; index < parentFields.size(); index++) {
      Schema.DescribeFieldResult parentFieldDescribe = parentFields[index].getDescribe();
      builtUpFieldName += index == parentFields.size() - 1
        ? parentFieldDescribe.getName()
        : (parentFieldDescribe.getRelationshipName() ?? parentFieldDescribe.getName().replace('__c', '__r')) + '.';
    }
    return builtUpFieldName;
  }

  private class SubQuery extends Query {
    private final Schema.SObjectField field;
    private final Schema.SObjectType objectType;
    private final Schema.SObjectField innerMatchingField;
    private final Query subcondition;

    public SubQuery(
      Schema.SObjectField field,
      Schema.SObjectType objectType,
      Schema.SObjectField innerMatchingField,
      Query subcondition
    ) {
      this.field = field;
      this.objectType = objectType;
      this.innerMatchingField = innerMatchingField;
      this.subcondition = subcondition;
    }

    public override String toString() {
      String whereClause = ' WHERE ' + this.subcondition.toString();
      this.bindVars.putAll(this.subcondition.getBindVars());
      return this.field.getDescribe().getName() +
        ' IN (SELECT ' +
        this.innerMatchingField +
        ' FROM ' +
        this.objectType +
        whereClause +
        ')';
    }
  }

  private abstract class DelimitedQuery extends Query {
    private final List<Query> queries;

    public DelimitedQuery(List<Query> queries) {
      super();
      this.queries = queries;
    }

    public abstract String getDelimiter();

    public override String toString() {
      String baseString = '(';
      for (Query innerQuery : this.queries) {
        String potentialString = innerQuery.toString();
        if (String.isNotBlank(potentialString) && potentialString != EMPTYISH_STRING) {
          baseString += potentialString + this.getDelimiter();
          this.bindVars.putAll(innerQuery.getBindVars());
        }
      }
      String potentialFinalString = baseString.removeEnd(this.getDelimiter()) + ')';
      return potentialFinalString == EMPTYISH_STRING ? '' : potentialFinalString;
    }
  }

  private class AndQuery extends DelimitedQuery {
    private final String delimiter = ' AND ';

    public AndQuery(List<Query> queries) {
      super(queries);
    }

    public override String getDelimiter() {
      return this.delimiter;
    }
  }

  private class OrQuery extends DelimitedQuery {
    private final String delimiter = ' OR ';

    public OrQuery(List<Query> queries) {
      super(queries);
    }

    public override String getDelimiter() {
      return this.delimiter;
    }
  }

  private class ParentQuery extends Query {
    private ParentQuery(List<SObjectField> parentFields, Operator operator, Object predicate) {
      super(getBuiltUpParentFieldName(parentFields), operator, predicate);
    }
  }

  protected Query() {
  }

  protected Query(String fieldName, Operator operator, Object predicate) {
    this.field = fieldName;
    this.operator = operator;
    this.predicate = predicate;
  }

  private Query(SObjectField fieldToken, Operator operator, Object predicate) {
    this(fieldToken.getDescribe().getName(), operator, predicate);
    this.fieldToken = fieldToken;
  }

  public Map<String, Object> getBindVars() {
    return this.bindVars;
  }

  public virtual override String toString() {
    String predicateValue = this.getPredicate(this.predicate);
    String printedValue = ' ' + (shouldPerformStrictEquals ? this.predicate : predicateValue);
    if (this.operator == Query.Operator.NOT_LIKE) {
      
      return String.format(this.getOperator(), new List<String>{ this.field }) + printedValue;
    }
    return this.field + ' ' + this.getOperator() + printedValue;
  }

  public String toSoslString() {
    String startingString = this.toString();
    for (String key : this.bindVars.keySet()) {
      startingString = startingString.replace(':' + key, this.getSoslPredicate(this.bindVars.get(key)));
    }
    if (this.predicate instanceof Iterable<Object>) {
      Iterable<Object> localPredicate = (Iterable<Object>) this.predicate;
      if (localPredicate.iterator().hasNext() == false) {
        return '';
      }
      String operatorToReplace;
      String newOperator;
      switch on this.operator {
        when EQUALS {
          operatorToReplace = '=';
          newOperator = 'IN';
        }
        when NOT_EQUALS {
          operatorToReplace = '!=';
          newOperator = 'NOT IN';
        }
      }
      if (operatorToReplace != null) {
        startingString = startingString.replace(operatorToReplace, newOperator);
      }
    }
    if (startingString.endsWith(EMPTYISH_STRING)) {
      this.isSoslEmpty = true;
    }
    return startingString;
  }

  public Boolean equals(Object thatObject) {
    if ((thatObject instanceof Query) == false) {
      return false;
    }
    Query that = (Query) thatObject;
    if (this.hasBeenCompared == false && that.hasBeenCompared == false) {
      that.toString();
      this.toString();
    }
    this.hasBeenCompared = true;
    that.hasBeenCompared = true;

    Boolean areEqual =
      this.field == that.field &&
      this.operator == that.operator &&
      this.bindVars.values() == that.bindVars.values();
    if (areEqual == false) {
      shouldPerformStrictEquals = true;
    }

    return areEqual;
  }

  public Integer hashCode() {
    return this.toString().hashCode();
  }

  private String getOperator() {
    String returnVal = '';
    switch on this.operator {
      when EQUALS {
        returnVal = '=';
      }
      when NOT_EQUALS {
        returnVal = '!=';
      }
      when LESS_THAN {
        returnVal = '<';
      }
      when LESS_THAN_OR_EQUAL {
        returnVal = '<=';
      }
      when GREATER_THAN {
        returnVal = '>';
      }
      when GREATER_THAN_OR_EQUAL {
        returnVal = '>=';
      }
      when ALIKE {
        returnVal = 'LIKE';
      }
      when NOT_LIKE {
        returnVal = 'NOT {0} LIKE';
      }
    }
    return returnVal;
  }

  private String getPredicate(Object predicate) {
    if (predicate == null || predicate instanceof Boolean) {
      return '' + predicate;
    }
    if (this.predicateKey == null) {
      this.predicateKey = String.format(BIND_VAR_MERGE, new List<String>{ BIND_VAR_NUMBER.format() });
      BIND_VAR_NUMBER++;
      this.bindVars.put(this.predicateKey, predicate);
    }
    return ':' + this.predicateKey;
  }

  private String getSoslPredicate(Object predicate) {
    if (predicate == null) {
      return 'null';
    } else if (predicate instanceof Datetime) {
      
      Datetime dt = (Datetime) predicate;
      return dt.format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'', 'Greenwich Mean Time');
    } else if (predicate instanceof Iterable<Object>) {
      Iterable<Object> localPredicates = (Iterable<Object>) predicate;
      if (localPredicates.iterator().hasNext() == false) {
        return EMPTYISH_STRING;
      }
      List<String> innerStrings = new List<String>();
      for (Object innerPred : localPredicates) {
        
        String innerString = this.getSoslPredicate(innerPred);
        innerStrings.add(innerString);
      }
      String start = '(';
      String ending = ')';
      return start + String.join(innerStrings, ',') + ending;
    } else if (predicate instanceof String) {
      String input = (String) predicate;
      return '\'' + String.escapeSingleQuotes(input) + '\'';
    }

    return String.valueOf(predicate);
  }
}
```


File `repository\QueryField.cls`:
```apex
public without sharing virtual class QueryField {
  private final String fieldValue;

  public QueryField(List<Schema.SObjectField> fieldTokens) {
    this(getFieldNames(fieldTokens));
  }

  public QueryField(List<String> fieldNames) {
    this.fieldValue = String.join(fieldNames, ',');
  }

  public QueryField(Schema.SObjectField token) {
    this.fieldValue = token.toString();
  }

  public QueryField(List<Schema.SObjectField> parentFieldChain, List<Schema.SObjectField> parentFields) {
    String base = '';
    while (parentFieldChain.isEmpty() == false) {
      base += parentFieldChain.remove(0).getDescribe().getRelationshipName() + '.';
    }
    List<String> fields = new List<String>();
    for (Schema.SObjectField field : parentFields) {
      fields.add(base + field.toString());
    }
    this.fieldValue = String.join(fields, ',');
  }

  public override String toString() {
    return this.fieldValue;
  }

  private static List<String> getFieldNames(List<Schema.SObjectField> fieldTokens) {
    List<String> fieldNames = new List<String>();
    for (Schema.SObjectField token : fieldTokens) {
      fieldNames.add(token.toString());
    }
    return fieldNames;
  }
}
```


File `repository\Repository.cls`:
```apex
@SuppressWarnings('PMD.AvoidBooleanMethodParameters,PMD.ExcessiveParameterList,PMD.ExcessivePublicCount,PMD.TooManyFields')
public virtual without sharing class Repository implements IRepository {
  private final Map<Schema.SObjectField, String> childToRelationshipNames;
  private final Map<String, String> relationshipNameToChildQuery = new Map<String, String>();
  private final IDML dml;
  @TestVisible
  private final List<Schema.SObjectField> queryFields;
  private final Set<String> selectFields = new Set<String>();
  private final Set<String> childBindVarKeys = new Set<String>();

  protected final Schema.SObjectType repoType;
  protected final Map<String, Object> bindVars = new Map<String, Object>();

  protected System.AccessLevel accessLevel = System.AccessLevel.SYSTEM_MODE;
  protected final Map<String, RepositorySortOrder> fieldToSortOrder = new Map<String, RepositorySortOrder>();

  private Boolean shouldPrintBindVars = false;
  private Boolean baseSelectUsed = false;
  private Boolean isSosl = false;
  private Boolean shouldAddChildFields = true;
  private Integer limitAmount;
  private SearchGroup soslSearchGroup = SearchGroup.ALL_FIELDS;

  public Repository(Schema.SObjectType repoType, List<Schema.SObjectField> queryFields, RepoFactory repoFactory) {
    this.dml = repoFactory.getDml();
    this.queryFields = queryFields;
    this.repoType = repoType;
    this.childToRelationshipNames = this.getChildRelationshipNames(repoType);
  }

  
  public virtual Cursor getCursor(List<Query> queries) {
    String finalQuery = this.getFinalQuery(queries);
    this.logQuery('cursor query:\n' + finalQuery);
    Cursor cursor = new Cursor(finalQuery, this.bindVars, this.accessLevel);
    this.clearState();
    System.debug(System.LoggingLevel.FINER, 'number of results: ' + cursor.getNumRecords());
    return cursor;
  }

  public Database.QueryLocator getQueryLocator(List<Query> queries) {
    return this.getQueryLocator(queries, this.shouldAddChildFields);
  }

  public Database.QueryLocator getQueryLocator(List<Query> queries, Boolean shouldAddChildFields) {
    Boolean originalValue = this.shouldAddChildFields;
    this.shouldAddChildFields = shouldAddChildFields;
    String finalQuery = this.getFinalQuery(queries);
    this.logQuery('query locator query:\n' + finalQuery);
    Database.QueryLocator locator = Database.getQueryLocatorWithBinds(
      this.getFinalQuery(queries),
      this.bindVars,
      this.accessLevel
    );
    this.clearState();
    this.shouldAddChildFields = originalValue;

    return locator;
  }

  public virtual List<SObject> get(Query query) {
    return this.get(new List<Query>{ query });
  }

  public virtual List<SObject> get(List<Query> queries) {
    String finalQuery = this.getFinalQuery(queries);
    return this.performQuery(finalQuery);
  }

  public virtual List<SObject> getAll() {
    return this.get(new List<Query>());
  }

  public Repository setLimit(Integer limitAmount) {
    this.limitAmount = limitAmount;
    return this;
  }

  public Repository addSortOrder(Schema.SObjectField fieldToken, RepositorySortOrder sortOrder) {
    this.fieldToSortOrder.put(fieldToken.getDescribe().getName(), sortOrder);
    return this;
  }

  public Repository addSortOrder(List<Schema.SObjectField> parentFieldChain, RepositorySortOrder sortOrder) {
    this.fieldToSortOrder.put(Query.getBuiltUpParentFieldName(parentFieldChain), sortOrder);
    return this;
  }

  public Repository addBaseFields(List<Schema.SObjectField> fields) {
    Set<Schema.SObjectField> uniqueFields = new Set<Schema.SObjectField>(this.queryFields);
    uniqueFields.addAll(fields);
    this.queryFields.clear();
    this.queryFields.addAll(uniqueFields);
    return this;
  }

  public Repository addFunctionBaseField(SelectFunction selectFunction, Schema.SObjectField field) {
    return this.addFunctionBaseFields(selectFunction, new List<Schema.SObjectField>{ field });
  }

  public Repository addFunctionBaseFields(SelectFunction selectFunction, List<Schema.SObjectField> fields) {
    Map<Schema.SObjectField, String> fieldsToAliases = new Map<Schema.SObjectfield, String>();
    for (Schema.SObjectField field : fields) {
      fieldsToAliases.put(
        field,
        this.queryFields.contains(field) ? field.getDescribe().getName() + '_' + selectFunction.name() : null
      );
    }
    return this.addFunctionBaseFields(selectFunction, fieldsToAliases);
  }

  public Repository addFunctionBaseFields(
    SelectFunction selectFunction,
    Map<Schema.SObjectField, String> fieldsToAliases
  ) {
    Map<String, String> fieldNamesToAliases = new Map<String, String>();
    for (Schema.SObjectField field : fieldsToAliases.keySet()) {
      fieldNamesToAliases.put(field.getDescribe().getName(), fieldsToAliases.get(field));
    }
    this.selectFields.addAll(this.getFunctionBaseFields(selectFunction, fieldNamesToAliases));
    return this;
  }

  public Repository addParentFields(Schema.SObjectField parentType, List<Schema.SObjectField> parentFields) {
    return this.addParentFields(new List<Schema.SObjectField>{ parentType }, parentFields);
  }

  public Repository addParentFields(List<Schema.SObjectField> parentTypes, List<Schema.SObjectField> parentFields) {
    this.selectFields.addAll(this.getParentFields(parentTypes, parentFields));
    return this;
  }

  public Repository addChildFields(Schema.SObjectField childFieldToken, List<Schema.SObjectField> childFields) {
    return this.addChildFields(
      childFieldToken,
      childFields,
      new List<Query>(),
      new Map<String, RepositorySortOrder>(),
      null
    );
  }

  public Repository addChildFields(Schema.SObjectField childFieldToken, IRepository childRepo) {
    return this.addChildFields(
      childFieldToken,
      childRepo,
      new List<Query>(),
      new Map<String, RepositorySortOrder>(),
      null
    );
  }

  public Repository addChildFields(
    Schema.SObjectField childFieldToken,
    List<Schema.SObjectField> childFields,
    List<Query> optionalWhereFilters,
    Map<String, RepositorySortOrder> fieldToSortOrder,
    Integer limitBy
  ) {
    return this.addChildFields(
      childFieldToken,
      new List<QueryField>{ new QueryField(childFields) },
      optionalWhereFilters,
      fieldToSortOrder,
      limitBy
    );
  }

  public Repository addChildFields(
    Schema.SObjectField childFieldToken,
    IRepository childRepo,
    List<Query> optionalWhereFilters,
    Map<String, RepositorySortOrder> fieldToSortOrder,
    Integer limitBy
  ) {
    Repository cr = (Repository) childRepo;
    cr.selectFields.addAll(cr.addSelectFields());
    cr.selectFields.addAll(cr.relationshipNameToChildQuery.values());
    Set<String> localSelectFields = cr.selectFields;
    localSelectFields.remove('Id');

    return this.addChildFields(
      childFieldToken,
      new List<QueryField>{ new QueryField(new List<String>(localSelectFields)) },
      optionalWhereFilters,
      fieldToSortOrder,
      limitBy
    );
  }

  public Repository addChildFields(
    Schema.SObjectField childFieldToken,
    List<QueryField> childFields,
    List<Query> optionalWhereFilters,
    Map<String, RepositorySortOrder> fieldToSortOrder,
    Integer limitBy
  ) {
    if (this.childToRelationshipNames.containsKey(childFieldToken) == false || this.shouldAddChildFields == false) {
      return this;
    }

    String baseSubselect =
      '(SELECT {0} FROM {1}' +
      this.addWheres(optionalWhereFilters) +
      this.getOrderBys(fieldToSortOrder) +
      this.getLimitAmount(limitBy) +
      ')';

    Set<String> childFieldNames = new Set<String>{ 'Id' };
    for (QueryField childField : childFields) {
      childFieldNames.add(childField.toString());
    }

    for (Query query : optionalWhereFilters) {
      this.childBindVarKeys.addAll(query.getBindVars().keySet());
    }

    String relationshipName = this.childToRelationshipNames.get(childFieldToken);
    String childFieldsToAdd = String.format(
      baseSubselect,
      new List<String>{ String.join(childFieldNames, ','), this.childToRelationshipNames.get(childFieldToken) }
    );
    this.relationshipNameToChildQuery.put(relationshipName, childFieldsToAdd);
    return this;
  }

  public Repository setAccessLevel(System.AccessLevel accessLevel) {
    this.setOptions(null, accessLevel);
    return this;
  }

  public Repository clearBindVars() {
    for (String key : this.bindVars.keySet()) {
      if (this.childBindVarKeys.contains(key) == false) {
        this.bindVars.remove(key);
      }
    }
    return this;
  }

  public Repository setShouldPrintBindVars(Boolean shouldPrintBindVars) {
    this.shouldPrintBindVars = shouldPrintBindVars;
    return this;
  }

  protected virtual Set<String> addSelectFields() {
    this.baseSelectUsed = true;
    return this.addSelectFields(this.queryFields);
  }

  protected virtual String getFinalQuery(List<Query> queries) {
    return this.getSelectAndFrom() +
      this.addWheres(queries) +
      this.getOrderBys(this.fieldToSortOrder) +
      this.getLimitAmount(this.limitAmount);
  }

  protected virtual void clearState() {
    this.clearBindVars();
    this.fieldToSortOrder.clear();
    this.limitAmount = null;
  }

  private List<String> getFunctionBaseFields(SelectFunction selectFunction, Map<String, String> fieldsToAliases) {
    List<String> functionBaseFields = new List<String>();
    for (String field : fieldsToAliases.keySet()) {
      Object alias = fieldsToAliases.get(field);
      functionBaseFields.add(
        String.format(selectFunction.name() + '({0}){1}', new List<Object>{ field, alias == null ? '' : ' ' + alias })
      );
    }
    return functionBaseFields;
  }

  private List<String> getParentFields(
    List<Schema.SObjectField> parentTypes,
    List<Schema.SObjectField> parentFieldTokens
  ) {
    List<String> parentFields = new List<String>();
    String parentBase = '';
    for (Schema.SObjectField parentToken : parentTypes) {
      String parentName = parentToken.getDescribe().getRelationshipName() ??
        parentToken.toString().replace('__c', '__r');
      parentBase += parentName + '.';
    }
    for (Schema.SObjectField parentField : parentFieldTokens) {
      parentFields.add(parentBase + parentField.getDescribe().getName());
    }
    return parentFields;
  }

  private Map<Schema.SObjectField, String> getChildRelationshipNames(Schema.SObjectType repoType) {
    Map<Schema.SObjectField, String> localChildToRelationshipNames = new Map<Schema.SObjectField, String>();
    for (Schema.ChildRelationship childRelationship : repoType.getDescribe().getChildRelationships()) {
      localChildToRelationshipNames.put(childRelationship.getField(), childRelationship.getRelationshipName());
    }
    return localChildToRelationshipNames;
  }

  private String getSelectAndFrom() {
    Set<String> localSelectFields = this.addSelectFields();
    if (this.baseSelectUsed) {
      localSelectFields.addAll(this.selectFields);
      this.baseSelectUsed = false;
    }
    localSelectFields.addAll(this.relationshipNameToChildQuery.values());
    return 'SELECT ' + String.join(localSelectFields, ', ') + '\nFROM ' + this.repoType;
  }

  private Set<String> addSelectFields(List<Schema.SObjectField> fields) {
    Set<String> fieldStrings = new Set<String>{ 'Id' };
    for (SObjectField field : fields) {
      fieldStrings.add(field.getDescribe().getName());
    }
    return fieldStrings;
  }

  private String addWheres(List<Query> queries) {
    List<String> wheres = new List<String>();
    for (Query qry : queries) {
      String possibleWhere = this.isSosl ? qry.toSoslString() : qry.toString();
      if (qry.isSoslEmpty() == false && String.isNotBlank(possibleWhere)) {
        wheres.add(possibleWhere);
        this.bindVars.putAll(qry.getBindVars());
      }
    }

    String whereClause = String.join(wheres, '\nAND ');
    return wheres.isEmpty() || String.isBlank(whereClause) ? '' : '\nWHERE ' + whereClause;
  }

  private List<SObject> performQuery(String finalQuery) {
    this.logQuery('performQuery query:\n' + finalQuery);
    List<SObject> results = Database.queryWithBinds(finalQuery, this.bindVars, this.accessLevel);
    this.clearState();
    System.debug(System.LoggingLevel.FINER, 'number of results: ' + results.size() + '\nresults: \n' + results);
    return results;
  }

  private String getOrderBys(Map<String, RepositorySortOrder> sortOrders) {
    String orderByString = '';
    if (sortOrders.isEmpty() == false) {
      orderByString += ' \nORDER BY ';
      String separator = ', ';
      for (String field : sortOrders.keySet()) {
        orderByString += field + ' ' + sortOrders.get(field).toString() + separator;
      }
      orderByString = orderByString.removeEnd(separator);
    }
    return orderByString;
  }

  private String getLimitAmount(Integer limitAmount) {
    return (limitAmount != null ? '\nLIMIT ' + limitAmount : '');
  }

  

  public List<List<SObject>> getSosl(String searchTerm, Query queryFilter) {
    return this.getSosl(searchTerm, new List<Query>{ queryFilter });
  }

  public virtual List<List<SObject>> getSosl(String searchTerm, List<Query> queryFilters) {
    return this.getSosl(searchTerm, queryFilters, new List<AdditionalSoslObject>());
  }

  public virtual List<List<SObject>> getSosl(
    String searchTerm,
    List<Query> queryFilters,
    List<AdditionalSoslObject> additionalSoslObjects
  ) {
    this.isSosl = true;
    List<AdditionalSoslObject> orderedSearchObjects = new List<AdditionalSoslObject>{
      new AdditionalSoslObject(this.repoType, this.queryFields, queryFilters, this.limitAmount)
    };
    orderedSearchObjects.addAll(additionalSoslObjects);
    String searchQuery =
      'FIND \'' +
      String.escapeSingleQuotes(searchTerm) +
      '\' IN ' +
      this.soslSearchGroup.name().replace('_', ' ') +
      ' RETURNING ' +
      this.formatAdditionalSoslObjects(orderedSearchObjects);

    this.logQuery('search query:\n' + searchQuery);
    List<List<SObject>> results = Search.query(searchQuery, this.accessLevel);
    System.debug(System.LoggingLevel.FINER, 'number of results: ' + results.size() + '\nresults: \n' + results);
    this.clearState();
    this.isSosl = false;
    return results;
  }

  public Repository setSearchGroup(SearchGroup searchGroup) {
    this.soslSearchGroup = searchGroup;
    return this;
  }

  private String formatAdditionalSoslObjects(List<AdditionalSoslObject> soslObjects) {
    List<String> objectsPreJoin = new List<String>();
    for (AdditionalSoslObject soslObject : soslObjects) {
      objectsPreJoin.add(
        soslObject.objectType +
          '(' +
          String.join(this.addSelectFields(soslObject.selectFields), ',') +
          this.addWheres(soslObject.queryFilters) +
          this.getLimitAmount(soslObject.queryLimit) +
          ')'
      );
    }
    return String.join(objectsPreJoin, ',');
  }

  protected void logQuery(String logString) {
    if (this.shouldPrintBindVars) {
      logString += '\n\nBind vars: ' + JSON.serializePretty(this.bindVars);
    }
    System.debug(System.LoggingLevel.DEBUG, logString);
  }

  
  public Database.SaveResult doInsert(SObject record) {
    return this.dml.doInsert(record);
  }
  public List<Database.SaveResult> doInsert(List<SObject> records) {
    return this.dml.doInsert(records);
  }

  public Database.SaveResult doUpdate(SObject record) {
    return this.dml.doUpdate(record);
  }
  public List<Database.SaveResult> doUpdate(List<SObject> records) {
    return this.dml.doUpdate(records);
  }

  public Database.UpsertResult doUpsert(SObject record) {
    return this.dml.doUpsert(record);
  }
  public List<Database.UpsertResult> doUpsert(List<SObject> records) {
    return this.dml.doUpsert(records);
  }
  public List<Database.UpsertResult> doUpsert(List<SObject> records, Schema.SObjectField field) {
    return this.dml.doUpsert(records, field);
  }

  public Database.UndeleteResult doUndelete(SObject record) {
    return this.dml.doUnDelete(record);
  }
  public List<Database.UndeleteResult> doUndelete(List<SObject> records) {
    return this.dml.doUndelete(records);
  }

  public Database.DeleteResult doDelete(SObject record) {
    return this.dml.doDelete(record);
  }
  public List<Database.DeleteResult> doDelete(List<SObject> records) {
    return this.dml.doDelete(records);
  }

  public Database.DeleteResult doHardDelete(SObject record) {
    return this.dml.doHardDelete(record);
  }
  public List<Database.DeleteResult> doHardDelete(List<SObject> records) {
    return this.dml.doHardDelete(records);
  }

  public Database.SaveResult publish(SObject event) {
    return this.dml.publish(event);
  }
  public List<Database.SaveResult> publish(List<SObject> events) {
    return this.dml.publish(events);
  }

  public IDML setOptions(Database.DMLOptions options) {
    return this.setOptions(options, this.accessLevel);
  }

  public IDML setOptions(Database.DMLOptions options, System.AccessLevel accessLevel) {
    this.accessLevel = accessLevel;
    return this.dml.setOptions(options, accessLevel);
  }
}
```


File `repository\RepositorySortOrder.cls`:
```apex
@SuppressWarnings('PMD.PropertyNamingConventions')
public class RepositorySortOrder {
  private final SortOrder sortOrder;
  private NullSortOrder nullSortOrder;

  public enum SortOrder {
    ASCENDING,
    DESCENDING
  }

  public enum NullSortOrder {
    FIRST,
    LAST
  }

  public static final RepositorySortOrder ASCENDING {
    get {
      if (ASCENDING == null) {
        ASCENDING = new RepositorySortOrder(SortOrder.ASCENDING);
      }
      return ASCENDING;
    }
    set;
  }

  public static final RepositorySortOrder DESCENDING {
    get {
      if (DESCENDING == null) {
        DESCENDING = new RepositorySortOrder(SortOrder.DESCENDING);
      }
      return DESCENDING;
    }
    set;
  }

  public RepositorySortOrder(SortOrder sortOrder) {
    this(sortOrder, null);
  }

  public RepositorySortOrder(SortOrder sortOrder, NullSortOrder nullSortOrder) {
    this.sortOrder = sortOrder;
    this.nullSortOrder = nullSortOrder;
  }

  public override String toString() {
    String base = this.sortOrder == RepositorySortOrder.SortOrder.ASCENDING ? 'ASC' : 'DESC';
    if (this.nullSortOrder != null) {
      base += ' ' + 'NULLS ' + this.nullSortOrder.name();
    }
    return base;
  }

  public Boolean equals(Object thatObj) {
    if (thatObj instanceof RepositorySortOrder) {
      RepositorySortOrder that = (RepositorySortOrder) thatObj;
      return this.nullSortOrder == that.nullSortOrder && this.sortOrder == that.sortOrder;
    }
    return false;
  }

  public Integer hashCode() {
    return this.toString().hashCode();
  }
}
```


File `repository\SearchGroup.cls`:
```apex
public enum SearchGroup {
  ALL_FIELDS,
  EMAIL_FIELDS,
  NAME_FIELDS,
  PHONE_FIELDS,
  SIDEBAR_FIELDS
}
```


File `repository\SelectFunction.cls`:
```apex
public enum SelectFunction {
  FORMAT,
  TOLABEL
}
```


File `repository\SObjectRepository.cls`:
```apex
public without sharing class SObjectRepository extends FieldLevelHistoryRepo {
  public SObjectRepository(
    Schema.SObjectType repoType,
    List<Schema.SObjectField> queryFields,
    RepoFactory repoFactory
  ) {
    super(repoType, queryFields, repoFactory);
  }
}
```
