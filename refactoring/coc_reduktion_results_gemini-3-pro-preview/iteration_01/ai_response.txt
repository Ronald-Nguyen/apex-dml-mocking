File `dml\DML.cls`:
```apex
public virtual without sharing class DML implements IDML {
  
  @TestVisible
  private static final Integer MAX_DML_CHUNKING = 10;

  private System.AccessLevel accessLevel = System.AccessLevel.SYSTEM_MODE;

  private Database.DMLOptions options {
    get {
      if (this.options == null) {
        this.options = new Database.DMLOptions();
      }
      this.options.OptAllOrNone = this.options.OptAllOrNone ?? true;
      return this.options;
    }
    set;
  }

  private enum OperationLoggingValue {
    INSERTING,
    UPDATING,
    UPSERTING,
    DELETING,
    UNDELETING,
    PUBLISHING
  }

  public virtual Database.SaveResult doInsert(SObject record) {
    return this.doInsert(new List<SObject>{ record })[0];
  }
  public virtual List<Database.SaveResult> doInsert(List<SObject> records) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.INSERTING, records);
    return Database.insert(records, this.options, this.accessLevel);
  }

  public virtual Database.SaveResult doUpdate(SObject record) {
    return this.doUpdate(new List<SObject>{ record })[0];
  }
  public virtual List<Database.SaveResult> doUpdate(List<SObject> records) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.UPDATING, records);
    return Database.update(records, this.options, this.accessLevel);
  }

  public virtual Database.UpsertResult doUpsert(SObject record) {
    return this.doUpsert(new List<SObject>{ record })[0];
  }

  public virtual List<Database.UpsertResult> doUpsert(List<SObject> records) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.UPSERTING, records);
    return Database.upsert(records, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual List<Database.UpsertResult> doUpsert(List<SObject> records, Schema.SObjectField externalIdField) {
    this.sortToPreventChunkingErrors(records);
    log(OperationLoggingValue.UPSERTING, records);
    return Database.upsert(records, externalIdField, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual Database.UndeleteResult doUndelete(SObject record) {
    return this.doUndelete(new List<SObject>{ record })[0];
  }
  public virtual List<Database.UndeleteResult> doUndelete(List<SObject> records) {
    log(OperationLoggingValue.UNDELETING, records);
    return Database.undelete(records, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual Database.DeleteResult doDelete(SObject record) {
    return this.doDelete(new List<SObject>{ record })[0];
  }
  public virtual List<Database.DeleteResult> doDelete(List<SObject> records) {
    log(OperationLoggingValue.DELETING, records);
    return Database.delete(records, this.options.OptAllOrNone, this.accessLevel);
  }

  public virtual Database.DeleteResult doHardDelete(SObject record) {
    return this.doHardDelete(new List<SObject>{ record })[0];
  }
  public virtual List<Database.DeleteResult> doHardDelete(List<SObject> records) {
    List<Database.DeleteResult> results = this.doDelete(records);
    System.debug(System.LoggingLevel.FINE, 'emptying recycling bin...');
    Database.emptyRecycleBin(records);
    return results;
  }

  public virtual Database.SaveResult publish(SObject event) {
    log(OperationLoggingValue.PUBLISHING, event);
    return EventBus.publish(event);
  }
  public virtual List<Database.SaveResult> publish(List<SObject> events) {
    log(OperationLoggingValue.PUBLISHING, events);
    return EventBus.publish(events);
  }

  public DML setOptions(Database.DMLOptions options) {
    return this.setOptions(options, this.accessLevel);
  }

  public DML setOptions(Database.DMLOptions options, System.AccessLevel accessLevel) {
    this.options = options ?? this.options;
    this.accessLevel = accessLevel;
    return this;
  }

  private void sortToPreventChunkingErrors(List<SObject> records) {
    if (records.size() < MAX_DML_CHUNKING) {
      return;
    }
    records.sort();
  }

  private static void log(OperationLoggingValue loggingValue, Object recordOrRecords) {
    Integer size = getRecordCount(recordOrRecords);
    String message = buildLogMessage(loggingValue, size);
    System.debug(System.LoggingLevel.FINE, message);
  }

  private static Integer getRecordCount(Object recordOrRecords) {
    return (recordOrRecords instanceof List<SObject>) ? ((List<SObject>) recordOrRecords).size() : 1;
  }

  private static String buildLogMessage(OperationLoggingValue loggingValue, Integer size) {
    return loggingValue.name().toLowerCase() + ' ' + size + ' record' + (size > 1 ? 's' : '') + '...';
  }
}
```

File `factory\RepoFactory.cls`:
```apex
public virtual class RepoFactory {
  private static final Map<Schema.SObjectType, IHistoryRepository> CACHED_REPOS = new Map<Schema.SObjectType, IHistoryRepository>();
  private Boolean shouldPrintBindVars = false;

  public Facade facade {
    get {
      if (this.facade == null) {
        this.facade = new Facade();
      }
      return this.facade;
    }
    protected set;
  }

  @SuppressWarnings('PMD.AvoidBooleanMethodParameters')
  public RepoFactory setShouldPrintBindVars(Boolean shouldPrintBindVars) {
    this.shouldPrintBindVars = shouldPrintBindVars;
    return this;
  }

  public IHistoryRepository getProfileRepo() {
    return this.facade.getRepo(Profile.SObjectType, new List<Schema.SObjectField>{ Profile.Name }, this);
  }

  public IDML getDML() {
    return this.facade.getDML();
  }

  public RepoFactory setFacade(Facade mockFacade) {
    if (Test.isRunningTest() == false) {
      throw new IllegalArgumentException('Should not call this outside of tests');
    }
    this.facade = mockFacade;
    return this;
  }

  public virtual class Facade {
    public virtual IDML getDML() {
      return new DML();
    }

    public virtual IHistoryRepository getRepo(
      Schema.SObjectType repoType,
      List<Schema.SObjectField> queryFields,
      RepoFactory repoFactory
    ) {
      IHistoryRepository repo = CACHED_REPOS.get(repoType);
      
      if (repo != null) {
        System.debug(System.LoggingLevel.FINER, 'Using cached repository of type: ' + repoType);
        repo.setShouldPrintBindVars(repoFactory.shouldPrintBindVars);
        return repo;
      }

      repo = new FieldLevelHistoryRepo(repoType, queryFields, repoFactory);
      CACHED_REPOS.put(repoType, repo);
      System.debug(System.LoggingLevel.FINER, 'Instantiating new repository of type: ' + repoType);
      
      repo.setShouldPrintBindVars(repoFactory.shouldPrintBindVars);
      return repo;
    }
  }
}
```

File `factory\RepoFactoryMock.cls`:
```apex
@SuppressWarnings('PMD.FieldNamingConventions')
@IsTest
public class RepoFactoryMock extends RepoFactory {
  @TestVisible
  private static final Map<Schema.SObjectType, List<AggregateRecord>> AggregateResults = new Map<Schema.SObjectType, List<AggregateRecord>>();
  @TestVisible
  private static final List<Aggregation> AggregatesMade = new List<Aggregation>();
  @TestVisible
  private static final List<SObject> QueryResults = new List<SObject>();
  @TestVisible
  private static final List<Query> QueriesMade = new List<Query>();
  @TestVisible
  private static final Map<SObjectType, List<Cursor>> CursorResults = new Map<SObjectType, List<Cursor>>();
  @TestVisible
  private static final Map<Schema.SObjectType, List<FieldLevelHistory>> HistoryResults = new Map<Schema.SObjectType, List<FieldLevelHistory>>();
  @TestVisible
  private static final Map<SObjectType, List<AggregateRepository.GroupBy>> GroupByFields = new Map<SObjectType, List<AggregateRepository.GroupBy>>();
  @TestVisible
  private static final Map<SObjectType, Map<String, RepositorySortOrder>> FieldToSortOrders = new Map<SObjectType, Map<String, RepositorySortOrder>>();

  private static final Map<Schema.SObjectType, List<Schema.ChildRelationship>> CACHED_CHILD_RELATIONSHIPS = new Map<Schema.SObjectType, List<Schema.ChildRelationship>>();

  @TestVisible
  private static Boolean alwaysUseMock = false;

  private class ChildrenSObjects {
    public final List<SObject> records;
    public final Boolean done = true;
    public final Integer totalSize;

    public ChildrenSObjects(List<SObject> records) {
      this.records = records;
      this.totalSize = records.size();
    }
  }

  public static SObject addChildrenToRecord(SObject record, Schema.SObjectField childField, List<SObject> children) {
    List<Schema.ChildRelationship> childRelationships = getCachedChildRelationships(record.getSObjectType());
    String relationshipName = findRelationshipName(childRelationships, childField);
    
    if (relationshipName != null) {
      return injectChildren(record, relationshipName, children);
    }
    return record;
  }

  private static List<Schema.ChildRelationship> getCachedChildRelationships(Schema.SObjectType sObjectType) {
    List<Schema.ChildRelationship> childRelationships = CACHED_CHILD_RELATIONSHIPS.get(sObjectType);
    if (childRelationships == null) {
      childRelationships = sObjectType
        .getDescribe(Schema.SObjectDescribeOptions.FULL)
        .getChildRelationships();
      CACHED_CHILD_RELATIONSHIPS.put(sObjectType, childRelationships);
    }
    return childRelationships;
  }

  private static String findRelationshipName(List<Schema.ChildRelationship> childRelationships, Schema.SObjectField childField) {
    for (Schema.ChildRelationship childRelationship : childRelationships) {
      if (childRelationship.getField() == childField) {
        return childRelationship.getRelationshipName();
      }
    }
    return null;
  }

  private static SObject injectChildren(SObject record, String relationshipName, List<SObject> children) {
    String serializedMeta = JSON.serialize(record).removeEnd('}');
    String childrenJson = '"' + relationshipName + '" : ' + JSON.serialize(new ChildrenSObjects(children));
    serializedMeta += ',' + childrenJson + '}';
    return (SObject) JSON.deserialize(serializedMeta, SObject.class);
  }

  public class FacadeMock extends RepoFactory.Facade {
    public override IDML getDML() {
      return new DMLMock();
    }

    public override IHistoryRepository getRepo(
      Schema.SObjectType repoType,
      List<Schema.SObjectField> queryFields,
      RepoFactory repoFactory
    ) {
      return getRepoFromSObjectType(repoType, super.getRepo(repoType, queryFields, repoFactory), repoFactory);
    }
  }

  private static IHistoryRepository getRepoFromSObjectType(
    SObjectType sObjectType,
    IAggregateRepository fallback,
    RepoFactory repoFactory
  ) {
    List<SObject> queriedResults = getResults(sObjectType);
    List<AggregateRecord> aggRecords = AggregateResults.get(sObjectType);
    List<FieldLevelHistory> historyRecords = HistoryResults.get(sObjectType);
    List<Cursor> cursorResults = CursorResults.get(sObjectType);

    if (shouldUseMock(queriedResults, aggRecords, historyRecords, cursorResults)) {
      RepoMock mock = new RepoMock(sObjectType, repoFactory);
      mock.results.addAll(queriedResults);
      if (aggRecords != null) {
        mock.aggRecords.addAll(aggRecords);
      }
      if (historyRecords != null) {
        mock.historyRecords.addAll(historyRecords);
      }
      return mock;
    }
    return (IHistoryRepository) fallback;
  }

  private static Boolean shouldUseMock(
    List<SObject> queriedResults, 
    List<AggregateRecord> aggRecords, 
    List<FieldLevelHistory> historyRecords, 
    List<Cursor> cursorResults
  ) {
    return queriedResults.size() > 0 ||
           (aggRecords != null && aggRecords.size() > 0) ||
           (historyRecords != null && historyRecords.size() > 0) ||
           (cursorResults != null && cursorResults.size() > 0) ||
           alwaysUseMock == true;
  }

  private static List<SObject> getResults(Schema.SObjectType sobjType) {
    List<SObject> resultList = new List<SObject>();
    for (SObject potentialResult : QueryResults) {
      if (potentialResult.getSObjectType() == sobjType) {
        resultList.add(potentialResult);
      }
    }
    return resultList;
  }

  private class RepoMock extends FieldLevelHistoryRepo {
    private final List<SObject> results = new List<SObject>();
    private final List<AggregateRecord> aggRecords = new List<AggregateRecord>();
    private final List<FieldLevelHistory> historyRecords = new List<FieldLevelHistory>();

    private RepoMock(Schema.SObjectType sObjectType, RepoFactory repoFactory) {
      super(sObjectType, new List<Schema.SObjectField>(), repoFactory);
    }

    public override Cursor getCursor(List<Query> queries) {
      QueriesMade.addAll(queries);
      List<Cursor> cursorResults = CursorResults.get(this.repoType);
      return cursorResults.remove(0);
    }

    public override List<FieldLevelHistory> getHistory(List<Query> queries) {
      QueriesMade.addAll(queries);
      this.trackFieldToSortOrder();
      return this.historyRecords;
    }

    public override List<SObject> getAll() {
      return this.get(new List<Query>());
    }

    public override List<SObject> get(Query query) {
      return this.get(new List<Query>{ query });
    }

    public override List<SObject> get(List<Query> queries) {
      QueriesMade.addAll(queries);
      this.trackFieldToSortOrder();
      this.clearState();
      return this.results;
    }

    public override List<List<SObject>> getSosl(
      String searchTerm,
      List<Query> queries,
      List<AdditionalSoslObject> additionalSoslObjects
    ) {
      QueriesMade.addAll(queries);
      List<List<SObject>> results = new List<List<SObject>>{ this.results };
      for (AdditionalSoslObject additionalSoslObject : additionalSoslObjects) {
        if (additionalSoslObject.objectType != this.repoType) {
          results.add(getResults(additionalSoslObject.objectType));
          QueriesMade.addAll(additionalSoslObject.queryFilters);
        }
      }
      return results;
    }

    public override Integer count(List<Query> queries) {
      QueriesMade.addAll(queries);
      List<AggregateRecord> results = AggregateResults.get(this.repoType);
      this.clearState();
      if (results == null) {
        return super.count(queries);
      } else if (results.isEmpty() == false) {
        return results.remove(0).getCount();
      }
      return null;
    }

    public override List<AggregateRecord> aggregate(List<Aggregation> aggregations, List<Query> queries) {
      AggregatesMade.addAll(aggregations);
      QueriesMade.addAll(queries);

      List<AggregateRepository.GroupBy> fields = GroupByFields.get(this.repoType);
      if (fields == null) {
        fields = new List<AggregateRepository.GroupBy>();
        GroupByFields.put(this.repoType, fields);
      }
      fields.addAll(this.groupedByFieldNames);

      this.trackFieldToSortOrder();

      return this.aggRecords;
    }

    private void trackFieldToSortOrder() {
      Map<String, RepositorySortOrder> localFieldToSortOrders = FieldToSortOrders.get(this.repoType);
      if (localFieldToSortOrders == null) {
        localFieldToSortOrders = new Map<String, RepositorySortOrder>();
        FieldToSortOrders.put(this.repoType, localFieldToSortOrders);
      }
      localFieldToSortOrders.putAll(this.fieldToSortOrder);
    }
  }

  public class CursorMock extends Cursor {
    private final List<SObject> records;

    public CursorMock(List<SObject> records) {
      this.records = records;
    }

    public override List<SObject> fetch(Integer start, Integer advanceBy) {
      List<SObject> clonedRecords = records.deepClone();
      clonedRecords.clear();
      for (Integer index = start; index < this.getAdvanceBy(start, advanceBy) + start; index++) {
        clonedRecords.add(this.records[index]);
      }
      return clonedRecords;
    }

    public override Integer getNumRecords() {
      return this.records.size();
    }
  }
}
```

File `repository\AggregateRepository.cls`:
```apex
public without sharing virtual class AggregateRepository extends Repository implements IAggregateRepository {
  protected final Set<GroupBy> groupedByFieldNames = new Set<GroupBy>();
  private final Set<String> havingFields = new Set<String>();
  private List<Aggregation> aggregations;
  private Boolean isNumberCountQuery = false;

  @TestVisible
  private class GroupBy {
    private final String selectName;
    private final String groupByName;

    public GroupBy(String groupByName, String alias) {
      this.selectName = groupByName + ' ' + alias;
      this.groupByName = groupByName;
    }

    public GroupBy(String fieldName) {
      this.selectName = fieldName;
      this.groupByName = fieldName;
    }

    public String getSelectName() {
      return this.selectName;
    }

    public String getGroupByName() {
      return this.groupByName;
    }

    public Boolean equals(Object other) {
      if (other instanceof GroupBy) {
        GroupBy that = (GroupBy) other;
        return this.groupByName == that.groupByName && this.selectName == that.selectName;
      }
      return false;
    }

    public Integer hashCode() {
      return this.selectName.hashCode() + this.groupByName.hashCode();
    }
  }

  public AggregateRepository(
    Schema.SObjectType repoType,
    List<Schema.SObjectField> queryFields,
    RepoFactory repoFactory
  ) {
    super(repoType, queryFields, repoFactory);
  }

  public IAggregateRepository groupBy(DateFunction dateFunction, Schema.SObjectField fieldToken, String alias) {
    String groupByName = this.getFormattedDateFunction(dateFunction, fieldToken);
    this.groupedByFieldNames.add(new GroupBy(groupByName, alias));
    return this;
  }

  public IAggregateRepository groupBy(Schema.SObjectField fieldToken) {
    this.groupedByFieldNames.add(new GroupBy(fieldToken.getDescribe().getName()));
    return this;
  }

  public IAggregateRepository groupBy(List<Schema.SObjectField> parentFieldChain) {
    String parentFieldGroupBy = '';
    while (parentFieldChain.size() > 1) {
      parentFieldGroupBy += parentFieldChain.remove(0).getDescribe().getRelationshipName() + '.';
    }
    this.groupedByFieldNames.add(new GroupBy(parentFieldGroupBy + parentFieldChain.remove(0).getDescribe().getName()));
    return this;
  }

  public IAggregateRepository addSortOrder(Aggregation aggregate, RepositorySortOrder sortOrder) {
    this.fieldToSortOrder.put(aggregate.getBaseAggregation(), sortOrder);
    return this;
  }

  public IAggregateRepository addSortOrder(
    DateFunction dateFunction,
    Schema.SObjectField fieldToken,
    RepositorySortOrder sortOrder
  ) {
    this.fieldToSortOrder.put(this.getFormattedDateFunction(dateFunction, fieldToken), sortOrder);
    return this;
  }

  public IAggregateRepository addHaving(Aggregation aggregation, Query.Operator operator, Object value) {
    Query aggQuery = new AggregateQuery(operator, value);
    this.havingFields.add(aggregation.getBaseAggregation() + ' ' + aggQuery);
    this.bindVars.putAll(aggQuery.getBindVars());
    return this;
  }

  public Integer count() {
    return this.count(new List<Query>());
  }
  public Integer count(Query query) {
    return this.count(new List<Query>{ query });
  }
  public virtual Integer count(List<Query> queries) {
    this.isNumberCountQuery = true;
    String finalQuery = this.getFinalQuery(queries);
    this.logQuery('count query:\n' + finalQuery);
    Integer recordCount = Database.countQueryWithBinds(finalQuery, this.bindVars, this.accessLevel);
    System.debug(System.LoggingLevel.FINER, 'number of results: ' + recordCount);
    this.clearState();
    this.isNumberCountQuery = false;
    return recordCount;
  }

  public List<AggregateRecord> aggregate(Aggregation aggregation) {
    return this.aggregate(new List<Aggregation>{ aggregation }, new List<Query>());
  }
  public List<AggregateRecord> aggregate(Aggregation aggregation, Query query) {
    return this.aggregate(new List<Aggregation>{ aggregation }, new List<Query>{ query });
  }
  public List<AggregateRecord> aggregate(Aggregation aggregation, List<Query> queries) {
    return this.aggregate(new List<Aggregation>{ aggregation }, queries);
  }
  public List<AggregateRecord> aggregate(List<Aggregation> aggregations) {
    return this.aggregate(aggregations, new List<Query>());
  }
  public List<AggregateRecord> aggregate(List<Aggregation> aggregations, Query query) {
    return this.aggregate(aggregations, new List<Query>{ query });
  }
  public virtual List<AggregateRecord> aggregate(List<Aggregation> aggregations, List<Query> queries) {
    this.aggregations = aggregations;

    List<AggregateResult> results = (List<AggregateResult>) this.get(queries);
    List<AggregateRecord> aggregateRecords = new List<AggregateRecord>();
    for (AggregateResult result : results) {
      AggregateRecord aggRecord = new AggregateRecord();
      aggRecord.putAll(result.getPopulatedFieldsAsMap());
      aggregateRecords.add(aggRecord);
    }

    this.clearState();
    return aggregateRecords;
  }

  protected virtual override Set<String> addSelectFields() {
    Set<String> baseFields = new Set<String>();
    if (this.isNumberCountQuery) {
      baseFields.add('COUNT()');
      return baseFields;
    }

    if (this.aggregations != null) {
      for (Aggregation agg : aggregations) {
        baseFields.add(agg.toString());
      }
    }

    for (GroupBy groupBy : this.groupedByFieldNames) {
      baseFields.add(groupBy.getSelectName());
    }
    return baseFields.isEmpty() ? super.addSelectFields() : baseFields;
  }

  protected override String getFinalQuery(List<Query> queries) {
    String baseString = super.getFinalQuery(queries);
    if (this.groupedByFieldNames.isEmpty()) {
      return baseString;
    }
    return this.applyGroupByLogic(baseString);
  }

  private String applyGroupByLogic(String baseQuery) {
    String orderByKey = '\nORDER BY';
    String orderByClause = '';
    String queryWithoutOrder = baseQuery;

    if (baseQuery.contains(orderByKey)) {
      String potentialOrderBy = baseQuery.substringAfter(orderByKey);
      orderByClause = orderByKey + potentialOrderBy;
      queryWithoutOrder = baseQuery.replace(orderByClause, '');
    }

    String groupByClause = this.buildGroupByClause();
    String havingClause = this.buildHavingClause();
    
    return queryWithoutOrder + groupByClause + havingClause + orderByClause;
  }

  private String buildGroupByClause() {
    List<String> groupByNames = new List<String>();
    for (GroupBy groupBy : this.groupedByFieldNames) {
      groupByNames.add(groupBy.getGroupByName());
    }
    return '\nGROUP BY ' + String.join(groupByNames, ',');
  }

  private String buildHavingClause() {
    if (this.havingFields.isEmpty()) {
      return '';
    }
    List<String> havingList = new List<String>(this.havingFields);
    return '\nHAVING ' + String.join(havingList, ',');
  }

  protected override void clearState() {
    super.clearState();
    this.havingFields.clear();
    this.groupedByFieldNames.clear();
    this.aggregations = null;
  }

  private String getFormattedDateFunction(DateFunction dateFunction, Schema.SObjectField fieldToken) {
    return dateFunction.name() + '(' + fieldToken + ')';
  }

  private class AggregateQuery extends Query {
    public AggregateQuery(Query.Operator op, Object value) {
      super('', op, value);
    }
  }
}
```

File `repository\Cursor.cls`:
```apex
public virtual without sharing class Cursor {
  public static final Integer MAX_FETCH_SIZE {
    get {
      MAX_FETCH_SIZE = MAX_FETCH_SIZE ?? maxRecordsPerFetchCall;
      return MAX_FETCH_SIZE;
    }
    private set;
  }

  private static final Integer MAX_FETCHES_PER_TRANSACTION = Limits.getLimitFetchCallsOnApexCursor();

  @TestVisible
  private static Integer maxRecordsPerFetchCall = 2000;

  @TestVisible
  private static Integer localFetchesMade;

  private Integer cursorNumRecords;
  private Integer fetchesPerTransaction = MAX_FETCHES_PER_TRANSACTION;
  private final Database.Cursor cursor;

  public Cursor(String finalQuery, Map<String, Object> bindVars, System.AccessLevel accessLevel) {
    try {
      this.cursor = Database.getCursorWithBinds(finalQuery, bindVars, accessLevel);
    } catch (FatalCursorException e) {
      System.debug(
        System.LoggingLevel.WARN,
        'Error creating cursor. This can happen if there are no records returned by the query: ' + e.getMessage()
      );
    }
  }

  public Cursor setFetchesPerTransaction(Integer possibleFetchesPerTransaction) {
    
    if (possibleFetchesPerTransaction == 0) {
      return this;
    }
    if (possibleFetchesPerTransaction > MAX_FETCHES_PER_TRANSACTION) {
      System.debug(
        System.LoggingLevel.DEBUG,
        'Fetches per transaction: ' +
          possibleFetchesPerTransaction +
          ' exceeded platform max fetches per transaction: ' +
          MAX_FETCHES_PER_TRANSACTION +
          ', defaulting to platform max'
      );
      possibleFetchesPerTransaction = MAX_FETCHES_PER_TRANSACTION;
    }
    this.fetchesPerTransaction = possibleFetchesPerTransaction;
    return this;
  }

  @SuppressWarnings('PMD.EmptyStatementBlock')
  protected Cursor() {
  }

  public virtual List<SObject> fetch(Integer start, Integer advanceBy) {
    if (this.getNumRecords() == 0) {
      System.debug(System.LoggingLevel.DEBUG, 'Bypassing fetch call, no records to fetch');
      return new List<SObject>();
    }
    localFetchesMade = localFetchesMade ?? 0;
    Integer localStart = start;
    List<SObject> results = new List<SObject>();
    
    while (canContinueFetching(localFetchesMade, results.size(), localStart, start, advanceBy)) {
      Integer actualAdvanceBy = this.getAdvanceBy(localStart, advanceBy);
      results.addAll(this.cursor?.fetch(localStart, actualAdvanceBy) ?? new List<SObject>());
      localStart += actualAdvanceBy;
      localFetchesMade++;
    }
    return results;
  }
  
  private Boolean canContinueFetching(
      Integer fetchesMade,
      Integer currentResultsSize,
      Integer localStart,
      Integer start,
      Integer advanceBy
  ) {
      return fetchesMade < this.fetchesPerTransaction &&
             currentResultsSize < this.getNumRecords() &&
             localStart < start + advanceBy;
  }

  public virtual Integer getNumRecords() {
    this.cursorNumRecords = this.cursorNumRecords ?? this.cursor?.getNumRecords() ?? 0;
    return this.cursorNumRecords;
  }

  protected Integer getAdvanceBy(Integer start, Integer advanceBy) {
    Integer possibleFetchSize = Math.min(advanceBy, this.getNumRecords() - start);
    if (possibleFetchSize > maxRecordsPerFetchCall) {
      System.debug(
        System.LoggingLevel.DEBUG,
        'Fetch size: ' +
          possibleFetchSize +
          ' exceeded platform max fetch size of ' +
          maxRecordsPerFetchCall +
          ', defaulting to max fetch size'
      );
      possibleFetchSize = maxRecordsPerFetchCall;
    } else if (possibleFetchSize < 0) {
      possibleFetchSize = 0;
    }
    return possibleFetchSize;
  }
}
```

File `repository\Query.cls`:
```apex
@SuppressWarnings(
  'PMD.EmptyStatementBlock,PMD.ExcessivePublicCount,PMD.ExcessiveParameterList,PMD.FieldNamingConventions'
)
public virtual class Query {
  private Boolean hasBeenCompared = false;
  private Boolean isSoslEmpty = false;
  private String predicateKey;

  public enum Operator {
    EQUALS,
    NOT_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUAL,
    GREATER_THAN,
    GREATER_THAN_OR_EQUAL,
    ALIKE, 
    NOT_LIKE
  }

  public final Operator operator;
  private final String field;
  private final Schema.SObjectField fieldToken;
  private final Object predicate;
  private final Map<String, Object> bindVars = new Map<String, Object>();

  private static final String BIND_VAR_MERGE = 'bindVar{0}';
  private static final String EMPTYISH_STRING = '()';

  private static Integer BIND_VAR_NUMBER = 0;
  @TestVisible
  private static Boolean shouldPerformStrictEquals = false;

  public Boolean isSoslEmpty() {
    return this.isSoslEmpty;
  }

  public Query usingParent(Schema.SObjectField parentField) {
    return this.usingParent(new List<Schema.SObjectField>{ parentField });
  }

  public Query usingParent(List<SObjectField> parentFields) {
    parentFields.add(this.fieldToken);
    return new ParentQuery(parentFields, this.operator, this.predicate);
  }

  public static Query subquery(Schema.SObjectField field, Schema.SObjectField innerMatchingField, Query subcondition) {
    return subquery(field, innerMatchingField.getDescribe().getSObjectType(), innerMatchingField, subcondition);
  }

  public static Query subquery(
    Schema.SObjectField field,
    Schema.SObjectType objectType,
    Schema.SObjectField innerMatchingField,
    Query subcondition
  ) {
    return new SubQuery(field, objectType, innerMatchingField, subcondition);
  }

  public static Query equals(SObjectField field, Object predicate) {
    return new Query(field, Operator.EQUALS, predicate);
  }

  public static Query notEquals(SObjectField field, Object predicate) {
    return new Query(field, Operator.NOT_EQUALS, predicate);
  }

  public static Query lessThan(SObjectField field, Object predicate) {
    return new Query(field, Operator.LESS_THAN, predicate);
  }

  public static Query lessThanOrEqual(SObjectField field, Object predicate) {
    return new Query(field, Operator.LESS_THAN_OR_EQUAL, predicate);
  }

  public static Query greaterThan(SObjectField field, Object predicate) {
    return new Query(field, Operator.GREATER_THAN, predicate);
  }

  public static Query greaterThanOrEqual(SObjectField field, Object predicate) {
    return new Query(field, Operator.GREATER_THAN_OR_EQUAL, predicate);
  }

  
  public static Query likeQuery(SObjectField field, Object predicate) {
    return new Query(field, Operator.ALIKE, predicate);
  }

  public static Query notLike(SObjectField field, Object predicate) {
    return new Query(field, Operator.NOT_LIKE, predicate);
  }

  
  public static Query orQuery(Query innerQuery, Query secondInnerQuery) {
    return orQuery(new List<Query>{ innerQuery, secondInnerQuery });
  }

  public static Query orQuery(List<Query> innerQueries) {
    return new OrQuery(innerQueries);
  }

  
  public static Query andQuery(Query innerQuery, Query secondInnerQuery) {
    return andQuery(new List<Query>{ innerQuery, secondInnerQuery });
  }

  public static Query andQuery(List<Query> innerQueries) {
    return new AndQuery(innerQueries);
  }

  public static String getBuiltUpParentFieldName(List<Schema.SObjectField> parentFields) {
    String builtUpFieldName = '';
    for (Integer index = 0; index < parentFields.size(); index++) {
      Schema.DescribeFieldResult parentFieldDescribe = parentFields[index].getDescribe();
      builtUpFieldName += index == parentFields.size() - 1
        ? parentFieldDescribe.getName()
        : (parentFieldDescribe.getRelationshipName() ?? parentFieldDescribe.getName().replace('__c', '__r')) + '.';
    }
    return builtUpFieldName;
  }

  private class SubQuery extends Query {
    private final Schema.SObjectField field;
    private final Schema.SObjectType objectType;
    private final Schema.SObjectField innerMatchingField;
    private final Query subcondition;

    public SubQuery(
      Schema.SObjectField field,
      Schema.SObjectType objectType,
      Schema.SObjectField innerMatchingField,
      Query subcondition
    ) {
      this.field = field;
      this.objectType = objectType;
      this.innerMatchingField = innerMatchingField;
      this.subcondition = subcondition;
    }

    public override String toString() {
      String whereClause = ' WHERE ' + this.subcondition.toString();
      this.bindVars.putAll(this.subcondition.getBindVars());
      return this.field.getDescribe().getName() +
        ' IN (SELECT ' +
        this.innerMatchingField +
        ' FROM ' +
        this.objectType +
        whereClause +
        ')';
    }
  }

  private abstract class DelimitedQuery extends Query {
    private final List<Query> queries;

    public DelimitedQuery(List<Query> queries) {
      super();
      this.queries = queries;
    }

    public abstract String getDelimiter();

    public override String toString() {
      String baseString = '(';
      for (Query innerQuery : this.queries) {
        String potentialString = innerQuery.toString();
        if (String.isNotBlank(potentialString) && potentialString != EMPTYISH_STRING) {
          baseString += potentialString + this.getDelimiter();
          this.bindVars.putAll(innerQuery.getBindVars());
        }
      }
      String potentialFinalString = baseString.removeEnd(this.getDelimiter()) + ')';
      return potentialFinalString == EMPTYISH_STRING ? '' : potentialFinalString;
    }
  }

  private class AndQuery extends DelimitedQuery {
    private final String delimiter = ' AND ';

    public AndQuery(List<Query> queries) {
      super(queries);
    }

    public override String getDelimiter() {
      return this.delimiter;
    }
  }

  private class OrQuery extends DelimitedQuery {
    private final String delimiter = ' OR ';

    public OrQuery(List<Query> queries) {
      super(queries);
    }

    public override String getDelimiter() {
      return this.delimiter;
    }
  }

  private class ParentQuery extends Query {
    private ParentQuery(List<SObjectField> parentFields, Operator operator, Object predicate) {
      super(getBuiltUpParentFieldName(parentFields), operator, predicate);
    }
  }

  protected Query() {
  }

  protected Query(String fieldName, Operator operator, Object predicate) {
    this.field = fieldName;
    this.operator = operator;
    this.predicate = predicate;
  }

  private Query(SObjectField fieldToken, Operator operator, Object predicate) {
    this(fieldToken.getDescribe().getName(), operator, predicate);
    this.fieldToken = fieldToken;
  }

  public Map<String, Object> getBindVars() {
    return this.bindVars;
  }

  public virtual override String toString() {
    String predicateValue = this.getPredicate(this.predicate);
    String printedValue = ' ' + (shouldPerformStrictEquals ? this.predicate : predicateValue);
    if (this.operator == Query.Operator.NOT_LIKE) {
      
      return String.format(this.getOperator(), new List<String>{ this.field }) + printedValue;
    }
    return this.field + ' ' + this.getOperator() + printedValue;
  }

  public String toSoslString() {
    String startingString = this.toString();
    for (String key : this.bindVars.keySet()) {
      startingString = startingString.replace(':' + key, this.getSoslPredicate(this.bindVars.get(key)));
    }
    if (this.predicate instanceof Iterable<Object>) {
      Iterable<Object> localPredicate = (Iterable<Object>) this.predicate;
      if (localPredicate.iterator().hasNext() == false) {
        return '';
      }
      String operatorToReplace;
      String newOperator;
      switch on this.operator {
        when EQUALS {
          operatorToReplace = '=';
          newOperator = 'IN';
        }
        when NOT_EQUALS {
          operatorToReplace = '!=';
          newOperator = 'NOT IN';
        }
      }
      if (operatorToReplace != null) {
        startingString = startingString.replace(operatorToReplace, newOperator);
      }
    }
    if (startingString.endsWith(EMPTYISH_STRING)) {
      this.isSoslEmpty = true;
    }
    return startingString;
  }

  public Boolean equals(Object thatObject) {
    if ((thatObject instanceof Query) == false) {
      return false;
    }
    Query that = (Query) thatObject;
    if (this.hasBeenCompared == false && that.hasBeenCompared == false) {
      that.toString();
      this.toString();
    }
    this.hasBeenCompared = true;
    that.hasBeenCompared = true;

    Boolean areEqual =
      this.field == that.field &&
      this.operator == that.operator &&
      this.bindVars.values() == that.bindVars.values();
    if (areEqual == false) {
      shouldPerformStrictEquals = true;
    }

    return areEqual;
  }

  public Integer hashCode() {
    return this.toString().hashCode();
  }

  private String getOperator() {
    String returnVal = '';
    switch on this.operator {
      when EQUALS {
        returnVal = '=';
      }
      when NOT_EQUALS {
        returnVal = '!=';
      }
      when LESS_THAN {
        returnVal = '<';
      }
      when LESS_THAN_OR_EQUAL {
        returnVal = '<=';
      }
      when GREATER_THAN {
        returnVal = '>';
      }
      when GREATER_THAN_OR_EQUAL {
        returnVal = '>=';
      }
      when ALIKE {
        returnVal = 'LIKE';
      }
      when NOT_LIKE {
        returnVal = 'NOT {0} LIKE';
      }
    }
    return returnVal;
  }

  private String getPredicate(Object predicate) {
    if (predicate == null || predicate instanceof Boolean) {
      return '' + predicate;
    }
    if (this.predicateKey == null) {
      this.predicateKey = String.format(BIND_VAR_MERGE, new List<String>{ BIND_VAR_NUMBER.format() });
      BIND_VAR_NUMBER++;
      this.bindVars.put(this.predicateKey, predicate);
    }
    return ':' + this.predicateKey;
  }

  private String getSoslPredicate(Object predicate) {
    if (predicate == null) {
      return 'null';
    }
    if (predicate instanceof Datetime) {
      return formatSoslDatetime((Datetime) predicate);
    }
    if (predicate instanceof Iterable<Object>) {
      return formatSoslIterable((Iterable<Object>) predicate);
    }
    if (predicate instanceof String) {
      return formatSoslString((String) predicate);
    }
    return String.valueOf(predicate);
  }

  private String formatSoslDatetime(Datetime dt) {
    return dt.format('yyyy-MM-dd\'T\'HH:mm:ss\'Z\'', 'Greenwich Mean Time');
  }

  private String formatSoslIterable(Iterable<Object> predicates) {
    if (predicates.iterator().hasNext() == false) {
      return EMPTYISH_STRING;
    }
    List<String> innerStrings = new List<String>();
    for (Object innerPred : predicates) {
      String innerString = this.getSoslPredicate(innerPred);
      innerStrings.add(innerString);
    }
    return '(' + String.join(innerStrings, ',') + ')';
  }

  private String formatSoslString(String input) {
    return '\'' + String.escapeSingleQuotes(input) + '\'';
  }
}
```